// =============================================================================
// NANO STORE FOOTER STATUS COMPONENT - ASTRO MCP COMPLIANT
// Uses Nano Stores for reactive health data following Astro best practices
// =============================================================================

import { useState, useEffect } from 'react';
import { useStore } from '@nanostores/react';
import { $healthData, $serviceMetrics } from '../../stores/healthStore.ts';
import type { IServiceResult } from '../../utils/serviceCheckers.ts';
import { formatTimestamp, onTimezoneChange } from '/src/utils/timezone.ts';

interface ServiceStatuses {
  frontend: IServiceResult | null;
  backend: IServiceResult | null;
  database: IServiceResult | null;
  cache: IServiceResult | null;
}

interface FooterStatusData {
  services: ServiceStatuses;
  overallStatus: {
    status: string;
    text: string;
    summary: string;
    color: string;
  };
  timestamp: number;
  upCount: number;
  totalCount: number;
}

export const EventDrivenFooterStatus: React.FC = () => {
  // Use Nano Stores for reactive health data (Astro MCP best practice)
  const healthData = useStore($healthData);
  const serviceMetrics = useStore($serviceMetrics);

  const [lastUpdateFormatted, setLastUpdateFormatted] = useState<string>('Loading...');
  const [isClient, setIsClient] = useState(false);

  // Fix hydration mismatch by detecting client-side rendering
  useEffect(() => {
    setIsClient(true);
  }, []);

  // Update formatted timestamp when health data changes or timezone changes
  useEffect(() => {
    const updateFormatted = () => {
      if (healthData.metadata.timestamp > 0) {
        const timestamp = new Date(healthData.metadata.timestamp);
        setLastUpdateFormatted(formatTimestamp(timestamp));
      } else {
        setLastUpdateFormatted('Loading...');
      }
    };

    updateFormatted();

    // Listen for timezone changes
    const cleanupTimezoneListener = onTimezoneChange(() => {
      updateFormatted();
    });

    console.log('🏁 EventDrivenFooterStatus: Using Nano Store data', {
      services: serviceMetrics.loaded,
      up: serviceMetrics.up,
      total: serviceMetrics.total
    });

    return () => {
      cleanupTimezoneListener();
    };
  }, [healthData.metadata.timestamp]);

  // Fix hydration mismatch by always showing loading state during SSR
  if (!isClient || !serviceMetrics.hasAnyData) {
    return (
      <div className="flex items-center space-x-4 footer-health-status">
        <div className="flex items-center space-x-2">
          <div className="w-3 h-3 rounded-full bg-gray-400 animate-pulse"></div>
          <span className="text-white/80 text-sm font-medium">
            Loading system status...
          </span>
        </div>
      </div>
    );
  }

  // Use data directly from Nano Stores (reactive and efficient)
  const { services, overallStatus } = healthData;
  const { up: upCount, total: totalCount } = serviceMetrics;

  // Service mappings for display
  const serviceDisplay = [
    { key: 'frontend', name: 'Frontend', icon: '🌐', service: services.frontend },
    { key: 'backend', name: 'Backend', icon: '🔧', service: services.backend },
    { key: 'database', name: 'Database', icon: '🐘', service: services.database },
    { key: 'cache', name: 'Cache', icon: '⚡', service: services.cache }
  ];

  // Get status color class
  const getStatusColorClass = (status: string): string => {
    switch (status) {
      case 'up': return 'bg-green-500';
      case 'degraded': return 'bg-yellow-500';
      case 'down': return 'bg-red-500';
      case 'error': return 'bg-orange-500';
      default: return 'bg-gray-500';
    }
  };

  return (
    <div className="flex items-center space-x-4 footer-health-status" data-component="health-status">
      {/* Overall Status */}
      <div className="flex items-center space-x-2">
        <div
          className={`w-3 h-3 rounded-full status-indicator ${getStatusColorClass(overallStatus.status)}`}
          data-status={overallStatus.status}
        />
        <span className="text-white/80 text-sm font-medium status-text" id="overall-status-text">
          System: {upCount}/{totalCount} Services
        </span>
      </div>

      {/* Individual Service Indicators */}
      <div className="flex items-center space-x-2">
        {serviceDisplay.map((item, index) => {
          const { key, name, icon, service } = item;

          if (!service) {
            return (
              <div key={key} className="flex items-center space-x-1 group relative">
                <div className="w-2 h-2 rounded-full bg-gray-400 animate-pulse" />
              </div>
            );
          }

          const responseTime = service.metrics?.responseTime;
          const formattedTime = typeof responseTime === 'number' ?
            `${responseTime}ms` :
            (typeof responseTime === 'string' ? responseTime : 'N/A');

          return (
            <div
              key={key}
              className="flex items-center space-x-1 group relative"
              data-service={name.toLowerCase()}
              data-service-index={index}
            >
              <div
                className={`w-2 h-2 rounded-full status-indicator ${getStatusColorClass(service.status)}`}
                data-status={service.status}
              />

              {/* Tooltip on hover */}
              <div className="absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-2 py-1
                              bg-black/80 text-white text-xs rounded opacity-0 group-hover:opacity-100
                              transition-opacity duration-200 pointer-events-none whitespace-nowrap z-50">
                <span className="service-tooltip">
                  {icon} {name}: <span className="status-text">{service.status.toUpperCase()}</span>
                  <span className="metrics-text"> | Response: {formattedTime}</span>
                </span>
              </div>
            </div>
          );
        })}
      </div>

      {/* Last Update Time */}
      <div className="text-white/50 text-xs timestamp" id="overall-status-timestamp">
        Updated: {lastUpdateFormatted}
      </div>
    </div>
  );
};