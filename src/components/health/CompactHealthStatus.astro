---
// =============================================================================
// COMPACT HEALTH STATUS - SERVER ISLAND FOR FOOTER (DRY/SOLID)
// =============================================================================
// Single Responsibility: Display compact health status for footer
// Uses shared service checkers - no duplicate logic!
// =============================================================================

import { 
  BackendServiceChecker,
  DatabaseServiceChecker, 
  CacheServiceChecker,
  FrontendServiceChecker
} from '../../utils/serviceCheckers.js';

// Server-side health checks using shared service checkers (DRY principle)
// Footer shows only CORE user-facing services (monitoring tools excluded)
const [backend, database, cache, frontend] = await Promise.all([
  BackendServiceChecker.checkHealth(),
  DatabaseServiceChecker.checkHealth(), 
  CacheServiceChecker.checkHealth(),
  FrontendServiceChecker.checkHealth()
]);

console.log('ğŸ” CompactHealthStatus service results:', {
  backend: backend.status,
  database: database.status,
  cache: cache.status,
  frontend: frontend.status
});

const services = [
  { name: 'Frontend', result: frontend, icon: 'ğŸŒ' },
  { name: 'Backend', result: backend, icon: 'ğŸ”§' },
  { name: 'Database', result: database, icon: 'ğŸ˜' },
  { name: 'Cache', result: cache, icon: 'âš¡' }
];

console.log('ğŸ” CompactHealthStatus services array:', services.map(s => ({ 
  name: s.name, 
  status: s.result.status,
  message: s.result.message 
})));

console.log('ğŸ” CompactHealthStatus counts:', {
  total: services.length,
  up: services.filter(s => s.result.status === 'up').length,
  statuses: services.map(s => s.result.status)
});

// SOLID: Single source of truth for status color mapping
function getStatusColor(status: string): string {
  switch (status) {
    case 'up': return 'green';
    case 'degraded': return 'yellow'; 
    case 'down': return 'red';
    case 'error': return 'orange';
    default: return 'gray';
  }
}

// Calculate overall system health
const upCount = services.filter(s => s.result.status === 'up').length;
const totalCount = services.length;
const overallHealth = upCount === totalCount ? 'up' : 
                     upCount >= totalCount * 0.5 ? 'degraded' : 'down';
---

<!-- Compact Health Status for Footer (Enhanced for React Integration) -->
<div class="flex items-center space-x-4 footer-health-status" data-component="health-status">
  <!-- Overall Status -->
  <div class="flex items-center space-x-2">
    <div 
      class="w-3 h-3 rounded-full status-indicator" 
      class:list={[`bg-${getStatusColor(overallHealth)}-500`]}
      data-status={overallHealth}
    ></div>
    <span class="text-white/80 text-sm font-medium status-text">
      System: {upCount}/{totalCount} Services
    </span>
  </div>

  <!-- Individual Service Indicators -->
  <div class="flex items-center space-x-2">
    {services.map(service => (
      <div 
        class="flex items-center space-x-1 group relative"
        key={service.name}
        data-service={service.name.toLowerCase()}
      >
        <div 
          class="w-2 h-2 rounded-full status-indicator" 
          class:list={[`bg-${getStatusColor(service.result.status)}-500`]}
          data-status={service.result.status}
        ></div>
        
        <!-- Tooltip on hover -->
        <div class="absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-2 py-1 
                    bg-black/80 text-white text-xs rounded opacity-0 group-hover:opacity-100 
                    transition-opacity duration-200 pointer-events-none whitespace-nowrap z-50">
          <span class="service-tooltip">
            {service.icon} {service.name}: <span class="status-text">{service.result.status.toUpperCase()}</span>
            {service.result.metrics.responseTime && 
              <span class="metrics-text"> | Response: {service.result.metrics.responseTime}ms</span>
            }
          </span>
        </div>
      </div>
    ))}
  </div>

  <!-- Last Update Time -->
  <div class="text-white/50 text-xs timestamp">
    Updated: {new Date().toLocaleTimeString()}
  </div>
</div>

<!-- Client-side script to emit consolidatedHealthUpdate events (Astro best practice for Server Islands) -->
<script define:vars={{ services, overallHealth }}>
  // =============================================================================
  // BEST PRACTICE: Server Island with Client-side Enhancement
  // Emit consolidatedHealthUpdate events using Server Island data (DRY/SOLID)
  // =============================================================================
  
  console.log('ğŸï¸ CompactHealthStatus Server Island: Emitting consolidatedHealthUpdate event');
  
  // Transform server data to match expected format
  const serviceData = {};
  services.forEach(service => {
    const serviceName = service.name.toLowerCase();
    serviceData[serviceName] = {
      status: service.result.status,
      message: service.result.message,
      metrics: service.result.metrics,
      timestamp: new Date().toISOString()
    };
  });
  
  // Emit the consolidatedHealthUpdate event that the embedded script is listening for
  const consolidatedEvent = new CustomEvent('consolidatedHealthUpdate', {
    detail: {
      services: serviceData,
      overallStatus: overallHealth,
      timestamp: Date.now()
    }
  });
  
  console.log('ğŸï¸ Server Island emitting consolidatedHealthUpdate:', consolidatedEvent.detail);
  window.dispatchEvent(consolidatedEvent);
  
  // Also set up periodic updates to keep service cards in sync (every 30 seconds)
  const updateInterval = setInterval(() => {
    // Re-fetch server island content and emit updates
    // This will happen automatically when the server island refreshes
    console.log('ğŸï¸ Server Island: Periodic update triggered');
    window.dispatchEvent(consolidatedEvent);
  }, 30000);
  
  console.log('ğŸï¸ CompactHealthStatus enhanced with client-side event emission');
</script>