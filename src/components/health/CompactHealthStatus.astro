---
// =============================================================================
// COMPACT HEALTH STATUS - OPTIMIZED SERVER ISLAND FOR FOOTER (DRY/SOLID)
// =============================================================================
// ASTRO PERFORMANCE OPTIMIZATIONS APPLIED:
// 1. ✅ Streaming: Individual service components render independently
// 2. ✅ Zero Props: Maximum caching performance (GET requests only)
// 3. ✅ Parallel Loading: Services load simultaneously
// Following Astro MCP recommendations for optimal performance
// =============================================================================

import {
  BackendServiceChecker,
  DatabaseServiceChecker,
  CacheServiceChecker,
  FrontendServiceChecker
} from '../../utils/serviceCheckers.ts';
import { formatTimestamp } from '../../utils/timezone.ts';

// CACHE-BUSTING: Add timestamp to prevent excessive caching of health data
// Health checks should be relatively fresh, not heavily cached
const cacheBreaker = Date.now();
console.log('🔄 CompactHealthStatus: Cache breaker:', cacheBreaker);

// Service checkers are imported, not passed as props
const serviceCheckers = {
  frontend: FrontendServiceChecker,
  backend: BackendServiceChecker,
  database: DatabaseServiceChecker,
  cache: CacheServiceChecker
};

const serviceConfigs = {
  frontend: { icon: '🌐', name: 'Frontend', priority: 1 },
  cache: { icon: '⚡', name: 'Cache', priority: 2 },
  database: { icon: '🐘', name: 'Database', priority: 3 },
  backend: { icon: '🔧', name: 'Backend', priority: 4 }
};

// ASTRO SPA OPTIMIZATION: Only initialize health data on true initial site load
// With transition:persist, this component persists across page navigations
// So we only need to set initial states once, not on every page
const healthResults = Object.entries(serviceConfigs).map(([key, config]) => ({
  service: key,
  result: {
    status: key === 'frontend' ? 'up' : 'loading',
    message: 'Waiting for initial health check...',
    metrics: null
  },
  config
}));

console.log('🎯 CompactHealthStatus: Initial load with loading states (persistent across navigation)');

// Sort by priority for optimal display order (fastest services first)
healthResults.sort((a, b) => a.config.priority - b.config.priority);

console.log('🚀 OptimizedCompactHealthStatus: Individual service indicators only');
console.log('🚀 Health results:', healthResults.map(hr => ({
  service: hr.service,
  status: hr.result.status,
  responseTime: hr.result.metrics?.responseTime
})));
---

<!-- OPTIMIZED COMPACT HEALTH STATUS (Individual Service Indicators Only) -->
<div class="flex items-center space-x-4 footer-health-status"
     data-component="health-status"
     data-health-results={JSON.stringify(healthResults)}>


  <!-- Individual Service Indicators (Streaming Optimized) -->
  <div class="flex items-center space-x-2">
    {healthResults.map(({ service, result, config }) => (
      <div class="flex items-center space-x-1 group relative"
           key={service}
           data-service={service}>

        <div class={`w-2 h-2 rounded-full transition-all duration-300 ${
          result.status === 'up' ? 'bg-green-400' :
          result.status === 'degraded' ? 'bg-yellow-400' :
          result.status === 'loading' ? 'bg-yellow-400 animate-pulse' :
          result.status === 'down' ? 'bg-red-400' :
          // Default states: frontend green (site is live), others pulsing yellow
          service === 'frontend' ? 'bg-green-400' : 'bg-yellow-400 animate-pulse'
        }`} data-status={result.status || (service === 'frontend' ? 'up' : 'loading')} data-service-name={service}></div>

        <!-- Optimized Tooltip -->
        <div class="absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-2 py-1
                    bg-black/90 text-white text-xs rounded opacity-0 group-hover:opacity-100
                    transition-opacity duration-200 pointer-events-none whitespace-nowrap z-50">
          <span class="service-tooltip">
            {config.icon} {config.name}: {result.status.toUpperCase()}
            {result.metrics?.responseTime &&
              <span> | {result.metrics.responseTime}ms</span>
            }
          </span>
        </div>
      </div>
    ))}
  </div>

  <!-- Timestamp Indicator -->
  <div class="text-white/50 text-xs">
    <span>Last Updated: </span><span id="health-timestamp">Never</span>
  </div>

</div>

<!-- ASTRO BEST PRACTICE: Using data attributes instead of define:vars -->
<script type="module">
  // =============================================================================
  // NANO STORE REACTIVE CLIENT - ASTRO MCP COMPLIANT
  // Subscribes to Nano Store updates for real-time health status changes
  // Following Astro best practices for reactive client-side components
  // =============================================================================

  import { formatTimestamp, onTimezoneChange } from '../../utils/timezone.ts';
  import { $healthData, $serviceMetrics } from '../../stores/healthStore.ts';

  console.log('🚀 CompactHealthStatus: Subscribing to Nano Store for real-time updates');

  // Function to update timestamp display with user's timezone preference
  function updateTimestamp(healthTimestamp) {
    const timestampElement = document.getElementById('health-timestamp');
    if (timestampElement) {
      // Use health data timestamp if provided, otherwise current time
      const timestampToUse = healthTimestamp ? new Date(healthTimestamp) : new Date();
      const newTimestamp = formatTimestamp(timestampToUse);
      console.log('🕐 HybridCompactHealthStatus: Updating timestamp to:', newTimestamp, 'from health data:', healthTimestamp);
      timestampElement.textContent = newTimestamp;
    } else {
      console.warn('🚨 HybridCompactHealthStatus: health-timestamp element not found');
    }
  }

  // Update UI based on Nano Store data (Astro MCP best practice)
  function updateHealthIndicators(healthData) {
    console.log('🎯 CompactHealthStatus: Updating UI from Nano Store', healthData);

    const { services, metadata } = healthData;

    // Update each service indicator
    ['frontend', 'backend', 'database', 'cache'].forEach(serviceName => {
      const serviceData = services[serviceName];
      const indicator = document.querySelector(`[data-service-name="${serviceName}"]`);

      if (indicator && serviceData) {
        // Remove all status classes
        indicator.className = 'w-2 h-2 rounded-full transition-all duration-300';

        // Add appropriate status class
        if (serviceData.status === 'up') {
          indicator.classList.add('bg-green-400');
        } else if (serviceData.status === 'down' || serviceData.status === 'error') {
          indicator.classList.add('bg-red-400');
        } else if (serviceData.status === 'degraded') {
          indicator.classList.add('bg-yellow-400');
        } else {
          indicator.classList.add('bg-yellow-400', 'animate-pulse');
        }

        indicator.setAttribute('data-status', serviceData.status);

        // Update tooltip
        const tooltip = indicator.parentElement?.querySelector('.service-tooltip');
        if (tooltip) {
          const icon = {
            frontend: '🌐',
            backend: '🔧',
            database: '🐘',
            cache: '⚡'
          }[serviceName];

          const name = serviceName.charAt(0).toUpperCase() + serviceName.slice(1);
          let tooltipText = `${icon} ${name}: ${serviceData.status.toUpperCase()}`;

          // Handle response time from either direct property or metrics object
          const responseTime = serviceData.responseTime || serviceData.metrics?.responseTime;
          if (responseTime !== undefined && responseTime !== null) {
            tooltipText += ` | ${responseTime}ms`;
          }

          tooltip.textContent = tooltipText;
        }
      }
    });

    // Update timestamp
    if (metadata.timestamp > 0) {
      updateTimestamp(new Date(metadata.timestamp));
    }
  }

  // ASTRO MCP BEST PRACTICE: Self-contained client-side health system
  // Following Single Responsibility Principle - this script ONLY handles client-side health initialization
  // Using inline approach to avoid ES module import issues in client scripts

  // SINGLETON PATTERN: Global health system manager (DRY principle)
  // DISABLED: SSE now handled in MainLayout following Astro MCP best practices
  if (false && !window.__healthSystemManager) {
    console.log('🚀 CompactHealthStatus: Creating singleton health system manager');

    // Create singleton health connection manager
    window.__healthSystemManager = {
      eventSource: null,
      isConnected: false,
      retryCount: 0,
      maxRetries: 5,
      retryDelay: 5000,

      async connect() {
        if (this.eventSource && this.isConnected) {
          console.log('✅ HealthSystem: Already connected, skipping');
          return;
        }

        try {
          import { getApiBaseUrl } from '../../constants/api.ts';
          const backendUrl = getApiBaseUrl();
          const sseUrl = `${backendUrl}/health/stream`;
          console.log('🔗 HealthSystem: Establishing SSE connection to:', sseUrl);
          this.eventSource = new EventSource(sseUrl);

          this.eventSource.onopen = () => {
            this.isConnected = true;
            this.retryCount = 0;
            console.log('✅ HealthSystem: SSE connection established');
          };

          this.eventSource.onmessage = (event) => {
            try {
              const data = JSON.parse(event.data);
              if (data.type === 'connection') {
                console.log('🔗 HealthSystem: Connection confirmed:', data.message);
                return;
              }
              console.log('📨 HealthSystem: Message received:', data);
            } catch (error) {
              console.warn('⚠️ HealthSystem: Error parsing message:', error);
            }
          };

          this.eventSource.addEventListener('service-update', (event) => {
            try {
              const serviceUpdate = JSON.parse(event.data);
              console.log('🎯 HealthSystem: Service update received:', serviceUpdate);

              // Handle both batch updates and individual service updates
              import('/src/stores/healthStore.ts').then(({ updateHealthData, getCurrentHealthData }) => {
                const updateTime = new Date(serviceUpdate.timestamp || Date.now());

                let services = {};

                if (serviceUpdate.services) {
                  // Batch update - use all services
                  services = serviceUpdate.services;
                  console.log('🎯 HealthSystem: Processing batch service update');
                } else if (serviceUpdate.service && serviceUpdate.status) {
                  // Individual service update - merge with existing data
                  const currentData = getCurrentHealthData();
                  services = { ...currentData.services };

                  // Update individual service
                  services[serviceUpdate.service] = {
                    status: serviceUpdate.status === 'healthy' ? 'up' : serviceUpdate.status,
                    message: `${serviceUpdate.service} service updated`,
                    metrics: {
                      responseTime: serviceUpdate.data?.response_time_ms || 0,
                      ...serviceUpdate.data
                    },
                    timestamp: updateTime
                  };

                  console.log('🎯 HealthSystem: Processing individual service update for:', serviceUpdate.service);
                } else {
                  console.warn('⚠️ HealthSystem: Unknown service update format:', serviceUpdate);
                  return;
                }

                // Transform to store format
                const healthData = {
                  services,
                  overallStatus: {
                    status: 'up', // Will be computed automatically
                    text: 'Services Updated',
                    summary: 'Services updated via SSE',
                    color: 'bg-green-500'
                  },
                  metadata: {
                    timestamp: updateTime.getTime(),
                    isPolling: false,
                    isVisible: true,
                    lastUpdateFormatted: formatTimestamp(updateTime)
                  }
                };

                console.log('🎯 HealthSystem: Updating store with:', healthData);
                updateHealthData(healthData);
              });
            } catch (error) {
              console.error('❌ HealthSystem: Error processing service update:', error);
            }
          });

          this.eventSource.addEventListener('service-error', (event) => {
            try {
              const errorData = JSON.parse(event.data);
              console.log('❌ HealthSystem: Service error received:', errorData);

              if (errorData.service && errorData.error) {
                // Update store with error state
                import('/src/stores/healthStore.ts').then(({ updateHealthData }) => {
                  const errorTimestamp = new Date(errorData.timestamp || Date.now());
                  const updatedServices = {};
                  updatedServices[errorData.service] = {
                    status: 'down',
                    message: errorData.error,
                    metrics: null
                  };

                  const healthData = {
                    services: updatedServices,
                    overallStatus: {
                      status: 'degraded',
                      text: 'Service Error Detected',
                      summary: `${errorData.service} service error`,
                      color: 'bg-red-500'
                    },
                    metadata: {
                      timestamp: errorTimestamp.getTime(),
                      isPolling: false,
                      isVisible: true,
                      lastUpdateFormatted: formatTimestamp(errorTimestamp)
                    }
                  };

                  console.log('❌ HealthSystem: Updating store with error:', healthData);
                  updateHealthData(healthData);
                });
              }
            } catch (error) {
              console.warn('⚠️ HealthSystem: Could not parse error event data');
            }
          });

          this.eventSource.onerror = (error) => {
            this.isConnected = false;
            console.error('❌ HealthSystem: SSE connection error:', error);
            this.handleRetry();
          };

        } catch (error) {
          console.error('💥 HealthSystem: Failed to create SSE connection:', error);
          this.handleRetry();
        }
      },

      handleRetry() {
        if (this.retryCount < this.maxRetries) {
          const delay = this.retryDelay * Math.pow(2, this.retryCount);
          this.retryCount++;

          console.log(`🔄 HealthSystem: Will retry in ${delay}ms (attempt ${this.retryCount}/${this.maxRetries})`);

          setTimeout(() => {
            console.log('🔄 HealthSystem: Retrying connection...');
            this.connect();
          }, delay);
        } else {
          console.log('💥 HealthSystem: Max retries exceeded');
        }
      },

      disconnect() {
        console.log('🛑 HealthSystem: Disconnecting');
        if (this.eventSource) {
          this.eventSource.close();
          this.eventSource = null;
        }
        this.isConnected = false;
      }
    };

    // Initialize connection
    window.__healthSystemManager.connect();

    // Setup cleanup on page unload
    window.addEventListener('beforeunload', () => {
      window.__healthSystemManager.disconnect();
    });
  }

  // NANO STORE SUBSCRIPTION: Subscribe to updates (using dynamic import for client-side)
  import('/src/stores/healthStore.ts').then(({ $healthData }) => {
    console.log('📡 CompactHealthStatus: Setting up Nano Store subscription');

    const unsubscribe = $healthData.subscribe(healthData => {
      console.log('📡 CompactHealthStatus: Nano Store update received', healthData);
      updateHealthIndicators(healthData);
    });

    // Initial update with current store data
    const initialData = $healthData.get();
    if (initialData) {
      updateHealthIndicators(initialData);
    }

    // Store cleanup function
    window.__healthStatusCleanup = unsubscribe;
  });


  // Listen for timezone changes
  const cleanupTimezone = onTimezoneChange(() => {
    const currentData = $healthData.get();
    if (currentData?.metadata?.timestamp) {
      updateTimestamp(new Date(currentData.metadata.timestamp));
    }
  });

  // Cleanup on page unload (though Astro usually handles this)
  window.addEventListener('beforeunload', () => {
    unsubscribe();
    cleanupTimezone();
  });
</script>