---
/**
 * StatusIndicator - SOLID Component Implementation
 * Single Responsibility: Display connection status with visual indicator
 * Following DRY principles with reusable status display
 */

// =============================================================================
// IMPORTS & TYPES
// =============================================================================
import { DASHBOARD_CSS_CLASSES } from '../types/dashboard.types';
import { formatTimestamp } from '/src/utils/timezone';

// =============================================================================
// COMPONENT PROPS
// =============================================================================
export interface Props {
  status: 'connected' | 'disconnected' | 'reconnecting';
  text: string;
  lastUpdated?: Date | undefined;
}

const {
  status,
  text,
  lastUpdated
} = Astro.props;

// =============================================================================
// SERVER-SIDE LOGIC (DRY Principle)
// =============================================================================

// Status-specific CSS classes
const getStatusClasses = (status: string): string => {
  const baseClasses = DASHBOARD_CSS_CLASSES.STATUS_INDICATOR;
  
  switch (status) {
    case 'connected':
      return `${baseClasses} ${DASHBOARD_CSS_CLASSES.STATUS_CONNECTED}`;
    case 'disconnected':
      return `${baseClasses} ${DASHBOARD_CSS_CLASSES.STATUS_DISCONNECTED}`;
    case 'reconnecting':
      return `${baseClasses} ${DASHBOARD_CSS_CLASSES.STATUS_RECONNECTING}`;
    default:
      return `${baseClasses} bg-gray-400`;
  }
};

const statusClasses = getStatusClasses(status);

// Format last updated time using timezone utility
const formatLastUpdated = (date?: Date): string => {
  if (!date) return '';
  return formatTimestamp(date);
};
---

<!-- =============================================================================
     STATUS INDICATOR (Single Responsibility)
     ============================================================================= -->

<div 
  class="flex items-center space-x-2" 
  data-connection-status
  data-status={status}
>
  <div 
    id="connection-indicator" 
    class={statusClasses}
    data-status-indicator={status}
  ></div>
  
  <div class="flex flex-col">
    <span 
      class="text-white/70 text-sm" 
      id="connection-text"
      data-status-text
    >
      {text}
    </span>
    
    {lastUpdated && (
      <span
        class="text-white/50 text-xs"
        data-last-updated
        data-timestamp={lastUpdated?.toISOString()}
      >
        Updated: {formatLastUpdated(lastUpdated)}
      </span>
    )}
  </div>
</div>

<script>
  // =============================================================================
  // ASTRO MCP BEST PRACTICE: Using data attributes instead of define:vars
  // No anti-patterns: Proper event-driven architecture with data attributes
  // =============================================================================

  import { formatTimestamp, onTimezoneChange } from '/src/utils/timezone';

  // ASTRO MCP COMPLIANT: Get data from DOM attributes (not define:vars)
  document.addEventListener('DOMContentLoaded', () => {
    const timestampElements = document.querySelectorAll('[data-last-updated][data-timestamp]');

    timestampElements.forEach(element => {
      const htmlElement = element as HTMLElement;
      const timestamp = htmlElement.getAttribute('data-timestamp');

      if (timestamp) {
        // Listen for timezone setting changes (following DRY/SOLID)
        const cleanupTimezoneListener = onTimezoneChange(() => {
          htmlElement.textContent = `Updated: ${formatTimestamp(new Date(timestamp))}`;
        });

        // Store cleanup function for proper memory management
        if (!htmlElement.dataset.timezoneListenerRegistered) {
          window.addEventListener('beforeunload', cleanupTimezoneListener);
          htmlElement.dataset.timezoneListenerRegistered = 'true';
        }
      }
    });
  });
</script>