---
// Comprehensive System Health Dashboard
import MainLayout from '../components/layout/MainLayout.astro';
---

<MainLayout title="System Health Dashboard" description="Comprehensive monitoring and diagnostics for all system services">
  
  <!-- Refresh Button Animation Styles -->
  <style>
    .refresh-pulse {
      animation: pulse 0.5s ease-in-out;
    }
  </style>

  <div class="max-w-7xl mx-auto py-8">
    <!-- Breadcrumb Navigation -->
    <nav class="mb-6">
      <a 
        href="/" 
        class="inline-flex items-center space-x-2 text-white/60 hover:text-white/90 text-sm transition-colors duration-200 group"
      >
        <svg class="w-4 h-4 group-hover:text-blue-400 transition-colors" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18" />
        </svg>
        <span class="group-hover:text-blue-400 transition-colors">Back to Main Dashboard</span>
      </a>
    </nav>
    
    <!-- Header -->
    <div class="glass-card p-8 mb-8">
      <h1 class="text-4xl font-bold text-white mb-3 text-center">üè• System Health Dashboard</h1>
      <p class="text-white/70 text-center mb-4">Comprehensive monitoring and diagnostics for all system services</p>
      
      <!-- Live Timezone Clock -->
      <div class="text-center mb-6">
        <div id="live-clock" class="text-2xl font-mono text-blue-300 mb-1">Loading time...</div>
        <div id="timezone-info" class="text-sm text-white/50">Timezone: Loading...</div>
      </div>
      
      <!-- Overall System Status -->
      <div class="bg-black/30 rounded-lg p-6 mb-6">
        <div class="flex items-center justify-center space-x-4">
          <div id="overall-status-indicator" class="w-4 h-4 rounded-full bg-blue-500 animate-pulse"></div>
          <div id="overall-status-text" class="text-xl font-semibold text-white">Loading&hellip;</div>
        </div>
        <div id="overall-status-summary" class="text-center text-white/60 mt-2">
          Loading system status from persistent health data...
        </div>
        <div id="overall-last-checked" class="text-center text-white/40 text-sm italic mt-1">
          Last Checked at: Never
        </div>
      </div>
      
      <!-- Global Controls -->
      <div class="flex flex-wrap justify-center gap-4 mb-6">
        <button id="refresh-all" class="glass-button px-6 py-3 bg-blue-500/20 text-blue-300 hover:bg-blue-500/30">
          üîÑ Refresh All Services
        </button>
        <button id="toggle-auto-refresh" class="glass-button px-6 py-3 bg-green-500/20 text-green-300 hover:bg-green-500/30">
          ‚è±Ô∏è Enable Auto-Refresh
        </button>
        <button id="export-report" class="glass-button px-6 py-3 bg-purple-500/20 text-purple-300 hover:bg-purple-500/30">
          üìä Export Health Report
        </button>
        <button id="test-connectivity" class="glass-button px-6 py-3 bg-orange-500/20 text-orange-300 hover:bg-orange-500/30">
          üåê Test Network Connectivity
        </button>
      </div>
    </div>

    <!-- Services Grid -->
    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
      
      <!-- Frontend Service -->
      <div class="glass-card p-6 relative">
        <div class="absolute top-4 right-4 flex gap-2">
          <button id="frontend-details" class="glass-button px-2 py-1 bg-purple-500/20 text-purple-300 hover:bg-purple-500/30 text-xs flex items-center space-x-1" title="View frontend service details">
            <svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
            <span>Details</span>
          </button>
        </div>
        
        <div class="flex items-center space-x-3 mb-4">
          <span class="text-2xl">üåê</span>
          <div>
            <h3 class="text-xl font-semibold text-white">Frontend Service</h3>
            <div class="flex items-center space-x-2">
              <div id="frontend-status-indicator" class="w-3 h-3 rounded-full bg-yellow-500 animate-pulse"></div>
              <span id="frontend-status-text" class="text-white/80">Checking...</span>
            </div>
            <div id="frontend-last-refreshed" class="text-xs text-white/50 italic mt-1">Last checked: Initializing...</div>
          </div>
        </div>
        
        <div class="space-y-3">
          <div class="bg-black/30 rounded-lg p-4">
            <h4 class="text-white font-semibold mb-2">Service Info</h4>
            <div class="space-y-1 text-xs">
              <div>Framework: <span id="frontend-framework" class="text-blue-400">Astro v5.x</span></div>
              <div>Port: <span id="frontend-port" class="text-blue-400">3000</span></div>
              <div>Environment: 
                <span id="frontend-env" class="ml-2 text-white">Development</span>
              </div>
            </div>
          </div>
          
          <div class="bg-black/30 rounded-lg p-4">
            <h4 class="text-white font-semibold mb-2">Performance Metrics</h4>
            <div class="grid grid-cols-2 gap-2 text-xs">
              <div>Page Load: <span id="frontend-load-time" class="text-blue-400">-</span></div>
              <div>Bundle Size: <span id="frontend-bundle-size" class="text-blue-400">~2.1MB</span></div>
              <div>Memory Usage: <span id="frontend-memory" class="text-blue-400">-</span></div>
            </div>
          </div>
          
          <div class="bg-black/30 rounded-lg p-4">
            <h4 class="text-white font-semibold mb-2">Features Status</h4>
            <div class="space-y-1 text-xs">
              <div id="frontend-feature-react">‚úÖ React Components</div>
              <div id="frontend-feature-typescript">‚úÖ TypeScript Support</div>
              <div id="frontend-feature-tailwind">‚úÖ Tailwind CSS</div>
              <div id="frontend-feature-hmr">‚úÖ Hot Module Reload</div>
            </div>
          </div>
        </div>
      </div>

      <!-- Backend Service -->
      <div class="glass-card p-6 relative">
        <div class="absolute top-4 right-4 flex gap-2">
          <button id="backend-refresh" class="glass-button px-2 py-1 bg-blue-500/20 text-blue-300 hover:bg-blue-500/30 text-xs flex items-center space-x-1" title="Refresh backend service">
            <svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
            </svg>
            <span>Refresh</span>
          </button>
          <button id="backend-details" class="glass-button px-2 py-1 bg-purple-500/20 text-purple-300 hover:bg-purple-500/30 text-xs flex items-center space-x-1" title="View backend service details">
            <svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
            <span>Details</span>
          </button>
        </div>
        
        <div class="flex items-center space-x-3 mb-4">
          <span class="text-2xl">üîß</span>
          <div>
            <h3 class="text-xl font-semibold text-white">Backend Service</h3>
            <div class="flex items-center space-x-2">
              <div id="backend-status-indicator" class="w-3 h-3 rounded-full bg-yellow-500 animate-pulse"></div>
              <span id="backend-status-text" class="text-white/80">Checking...</span>
            </div>
            <div id="backend-last-refreshed" class="text-xs text-white/50 italic mt-1">Last checked: Initializing...</div>
          </div>
        </div>
        
        <div class="space-y-3">
          <div class="bg-black/30 rounded-lg p-4">
            <h4 class="text-white font-semibold mb-2">Service Info</h4>
            <div class="space-y-1 text-xs">
              <div>Framework: <span id="backend-framework" class="text-blue-400" data-framework="backend">FastAPI + Python 3.13</span></div>
              <div>Version: <span id="backend-version" class="text-blue-400">-</span></div>
            </div>
          </div>
          
          <div class="bg-black/30 rounded-lg p-4">
            <h4 class="text-white font-semibold mb-2">Component Status</h4>
            <div class="space-y-1 text-xs">
              <div id="backend-observability">‚è≥ Observability Manager</div>
              <div id="backend-metrics">‚è≥ Metrics Collector</div>
              <div id="backend-health-checker">‚è≥ Health Checker</div>
              <div id="backend-alert-manager">‚è≥ Alert Manager</div>
              <div id="backend-performance">‚è≥ Performance Monitor</div>
            </div>
          </div>
          
          <div class="bg-black/30 rounded-lg p-4">
            <h4 class="text-white font-semibold mb-2">Quick Access</h4>
            <div class="space-y-2">
              <button onclick="window.open('http://localhost:8000/docs', '_blank')" class="glass-button w-full py-1 text-xs bg-blue-500/20 text-blue-300 hover:bg-blue-500/30 flex items-center justify-center space-x-1">
                <span>üîß</span>
                <span>Backend API Docs</span>
              </button>
              <button onclick="window.open('http://localhost:3001', '_blank')" class="glass-button w-full py-1 text-xs bg-orange-500/20 text-orange-300 hover:bg-orange-500/30 flex items-center justify-center space-x-1">
                <span>üìà</span>
                <span>Grafana Dashboard</span>
              </button>
              <button onclick="window.open('http://localhost:9090', '_blank')" class="glass-button w-full py-1 text-xs bg-red-500/20 text-red-300 hover:bg-red-500/30 flex items-center justify-center space-x-1">
                <span>üìä</span>
                <span>Prometheus Metrics</span>
              </button>
            </div>
          </div>
        </div>
      </div>

      <!-- Database Service -->
      <div class="glass-card p-6 relative">
        <div class="absolute top-4 right-4 flex gap-2">
          <button id="postgres-refresh" class="glass-button px-2 py-1 bg-blue-500/20 text-blue-300 hover:bg-blue-500/30 text-xs flex items-center space-x-1" title="Refresh PostgreSQL service">
            <svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
            </svg>
            <span>Refresh</span>
          </button>
          <button id="postgres-details" class="glass-button px-2 py-1 bg-purple-500/20 text-purple-300 hover:bg-purple-500/30 text-xs flex items-center space-x-1" title="View PostgreSQL service details">
            <svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
            <span>Details</span>
          </button>
        </div>
        
        <div class="flex items-center space-x-3 mb-4">
          <span class="text-2xl">üêò</span>
          <div>
            <h3 class="text-xl font-semibold text-white">PostgreSQL Database</h3>
            <div class="flex items-center space-x-2">
              <div id="postgres-status-indicator" class="w-3 h-3 rounded-full bg-yellow-500 animate-pulse"></div>
              <span id="postgres-status-text" class="text-white/80">Checking...</span>
            </div>
            <div id="postgres-last-refreshed" class="text-xs text-white/50 italic mt-1">Last checked: Initializing...</div>
          </div>
        </div>
        
        <div class="space-y-3">
          <div class="bg-black/30 rounded-lg p-4">
            <h4 class="text-white font-semibold mb-2">Database Info</h4>
            <div class="grid grid-cols-2 gap-2 text-xs">
              <div>Version: <span id="postgres-version" class="text-blue-400">PostgreSQL 15</span></div>
              <div>Size: <span id="postgres-size" class="text-blue-400">-</span></div>
            </div>
          </div>
          
          <div class="bg-black/30 rounded-lg p-4">
            <h4 class="text-white font-semibold mb-2">Connection Pool</h4>
            <div class="grid grid-cols-2 gap-2 text-xs">
              <div>Max Connections: <span class="text-blue-400" data-postgres-max-connections>200</span></div>
              <div>Active: <span id="postgres-active-connections" class="text-blue-400">-</span></div>
            </div>
          </div>
          
          <div class="bg-black/30 rounded-lg p-4">
            <h4 class="text-white font-semibold mb-2">Extensions</h4>
            <div class="space-y-1 text-xs">
              <div>‚úÖ pg_stat_statements</div>
              <div>‚úÖ pgcrypto</div>
            </div>
          </div>
          
          <div id="postgres-stats" class="bg-black/30 rounded-lg p-4">
            <h4 class="text-white font-semibold mb-2">Performance Stats</h4>
            <div class="space-y-1 text-xs">
              <div>Query Time: <span id="postgres-query-time" class="text-blue-400">CALCULATING...</span></div>
              <div>Cache Hit Ratio: <span id="postgres-cache-hit" class="text-blue-400">CALCULATING...</span></div>
            </div>
          </div>
        </div>
      </div>

      <!-- Cache Service -->
      <div class="glass-card p-6 relative">
        <div class="absolute top-4 right-4 flex gap-1">
          <button id="redis-refresh" class="glass-button px-2 py-1 bg-blue-500/20 text-blue-300 hover:bg-blue-500/30 text-xs flex items-center space-x-1" title="Refresh Redis service">
            <svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
            </svg>
            <span>Refresh</span>
          </button>
          <button id="redis-details" class="glass-button px-2 py-1 bg-purple-500/20 text-purple-300 hover:bg-purple-500/30 text-xs flex items-center space-x-1" title="View Redis service details">
            <svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
            <span>Details</span>
          </button>
          <button id="test-redis-connection" class="glass-button px-2 py-1 bg-green-500/20 text-green-300 hover:bg-green-500/30 text-xs flex items-center space-x-1" title="Test Redis connection">
            <svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1" />
            </svg>
            <span>Test</span>
          </button>
        </div>
        
        <div class="flex items-center space-x-3 mb-4">
          <span class="text-2xl">‚ö°</span>
          <div>
            <h3 class="text-xl font-semibold text-white">Redis Cache</h3>
            <div class="flex items-center space-x-2">
              <div id="redis-status-indicator" class="w-3 h-3 rounded-full bg-yellow-500 animate-pulse"></div>
              <span id="redis-status-text" class="text-white/80">Checking...</span>
            </div>
            <div id="redis-last-refreshed" class="text-xs text-white/50 italic mt-1">Last checked: Initializing...</div>
          </div>
        </div>
        
        <div class="space-y-3">
          <div class="bg-black/30 rounded-lg p-4">
            <h4 class="text-white font-semibold mb-2">Configuration</h4>
            <div class="space-y-1 text-xs">
              <div>Version: <span class="text-blue-400" data-redis-version>7.4.5</span></div>
              <div>Mode: 
                <span id="redis-mode" class="ml-2 text-white">Standalone</span>
              </div>
            </div>
          </div>
          
          <div class="bg-black/30 rounded-lg p-4">
            <h4 class="text-white font-semibold mb-2">Memory & Performance</h4>
            <div class="space-y-2 text-xs">
              <div class="flex justify-between">
                <span>Max Memory:</span>
                <span class="text-blue-400">256MB</span>
              </div>
              <div class="flex justify-between">
                <span>Used Memory:</span>
                <span id="redis-memory-used" class="text-blue-400">CALCULATING...</span>
              </div>
              <div class="flex justify-between">
                <span>Hit Rate:</span>
                <span id="redis-hit-rate" class="text-blue-400">CALCULATING...</span>
              </div>
            </div>
          </div>

          <div class="bg-black/30 rounded-lg p-4">
            <h4 class="text-white font-semibold mb-2">Configuration Test</h4>
            <div class="space-y-1 text-xs">
              <div id="redis-config-test" class="text-yellow-400">‚è≥ Checking config...</div>
            </div>
          </div>
        </div>
      </div>


    </div>

    <!-- Detailed Diagnostics Section -->
    <div class="grid grid-cols-1 gap-8 mb-8">
      
      <!-- Network Connectivity Test -->
      <div class="glass-card p-6">
        <div class="flex items-center justify-between mb-4">
          <div>
            <h2 class="text-2xl font-bold text-white">üåê Network Connectivity Test</h2>
            <div class="text-xs text-white/60">Last updated: <span id="connectivity-last-update">-</span></div>
          </div>
          <div class="flex gap-2">
            <button id="test-cors" class="glass-button px-3 py-1 text-xs bg-green-500/20 text-green-300">Test CORS</button>
            <button id="test-latency" class="glass-button px-3 py-1 text-xs bg-blue-500/20 text-blue-300">Test Latency</button>
          </div>
        </div>
        
        <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
          <div class="bg-black/30 rounded-lg p-4">
            <h3 class="text-white font-semibold mb-3">Frontend ‚Üî Backend</h3>
            <div class="space-y-2 text-sm">
              <div class="flex justify-between">
                <span>Status:</span>
                <span id="fe-be-status" class="text-yellow-400">Testing...</span>
              </div>
              <div class="flex justify-between">
                <span>Latency:</span>
                <span id="fe-be-latency" class="text-blue-400">-</span>
              </div>
              <div class="flex justify-between">
                <span>CORS:</span>
                <span id="fe-be-cors" class="text-blue-400">-</span>
              </div>
            </div>
          </div>
          
          <div class="bg-black/30 rounded-lg p-4">
            <h3 class="text-white font-semibold mb-3">Backend ‚Üî Database</h3>
            <div class="space-y-2 text-sm">
              <div class="flex justify-between">
                <span>Status:</span>
                <span id="be-db-status" class="text-yellow-400">Testing...</span>
              </div>
              <div class="flex justify-between">
                <span>Query Time:</span>
                <span id="be-db-query" class="text-blue-400">-</span>
              </div>
            </div>
          </div>
          
          <div class="bg-black/30 rounded-lg p-4">
            <h3 class="text-white font-semibold mb-3">Backend ‚Üî Cache</h3>
            <div class="space-y-2 text-sm">
              <div class="flex justify-between">
                <span>Status:</span>
                <span id="be-cache-status" class="text-yellow-400">Testing...</span>
              </div>
              <div class="flex justify-between">
                <span>Ping Time:</span>
                <span id="be-cache-ping" class="text-blue-400">-</span>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Debugging Output Section -->
        <div id="debug-output" class="bg-black/40 rounded-lg p-4 mt-6" style="display: none;">
          <div class="flex items-center justify-between mb-3">
            <h3 class="text-white font-semibold">üîç Network Test Debug Output</h3>
            <div class="flex gap-2">
              <button id="copy-debug" class="glass-button px-3 py-1 bg-blue-500/20 text-blue-300 hover:bg-blue-500/30 text-xs flex items-center space-x-1" title="Copy debug output to clipboard">
                <svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
                </svg>
                <span>Copy</span>
              </button>
              <button id="clear-debug" class="glass-button px-3 py-1 bg-red-500/20 text-red-300 hover:bg-red-500/30 text-xs flex items-center space-x-1" title="Clear debug output">
                <svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                </svg>
                <span>Clear</span>
              </button>
            </div>
          </div>
          <div id="debug-content" class="bg-black/60 rounded p-3 max-h-64 overflow-y-auto">
            <div class="text-green-400 text-xs font-mono">Debug output will appear here after running tests...</div>
          </div>
        </div>
      </div>

      <!-- System Performance Overview -->
      <div class="glass-card p-6">
        <div class="flex items-center justify-between mb-4">
          <h2 class="text-2xl font-bold text-white">üìä System Performance Overview</h2>
          <div class="text-xs text-white/60">Last updated: <span id="last-update-time">-</span></div>
        </div>
        
        <div class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-4">
          <div class="bg-black/30 rounded-lg p-4 text-center">
            <div class="text-2xl font-bold text-blue-400" id="total-requests">-</div>
            <div class="text-xs text-white/60">Total Requests</div>
          </div>
          <div class="bg-black/30 rounded-lg p-4 text-center">
            <div class="text-2xl font-bold text-green-400" id="avg-response-time">-</div>
            <div class="text-xs text-white/60">Avg Response Time</div>
          </div>
          <div class="bg-black/30 rounded-lg p-4 text-center">
            <div class="text-2xl font-bold text-purple-400" id="uptime">-</div>
            <div class="text-xs text-white/60">System Uptime</div>
          </div>
          <div class="bg-black/30 rounded-lg p-4 text-center">
            <div class="text-2xl font-bold text-orange-400" id="error-rate">-</div>
            <div class="text-xs text-white/60">Error Rate</div>
          </div>
        </div>
        
        <!-- Performance Chart Placeholder -->
        <div class="bg-black/30 rounded-lg p-4">
          <h4 class="text-white font-semibold mb-2">Response Time Trend (Last 10 requests)</h4>
          <div id="performance-chart" class="h-20 flex items-end justify-between">
            <!-- Chart bars will be dynamically generated -->
            <div class="text-white/40 text-center w-full">Performance data will appear here after tests</div>
          </div>
        </div>
      </div>

      <!-- Raw Data and Export -->
      <div class="glass-card p-6">
        <div class="flex items-center justify-between mb-4">
          <h2 class="text-2xl font-bold text-white">üîç Raw Data & Export</h2>
          <div class="flex gap-2">
            <button id="clear-data" class="glass-button px-3 py-1 text-xs bg-red-500/20 text-red-300">Clear Data</button>
            <button id="copy-data" class="glass-button px-3 py-1 text-xs bg-blue-500/20 text-blue-300">Copy JSON</button>
          </div>
        </div>
        
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
          <div class="bg-black/30 rounded-lg p-4">
            <h3 class="text-white font-semibold mb-3">Latest Backend Response</h3>
            <pre id="raw-backend-data" class="text-xs text-green-400 whitespace-pre-wrap overflow-x-auto max-h-40">No data yet...</pre>
          </div>
          <div class="bg-black/30 rounded-lg p-4">
            <h3 class="text-white font-semibold mb-3">Health Summary</h3>
            <pre id="health-summary" class="text-xs text-blue-400 whitespace-pre-wrap overflow-x-auto max-h-40">No data yet...</pre>
          </div>
        </div>
        
        <div class="mt-4 bg-black/30 rounded-lg p-4">
          <div class="flex items-center justify-between mb-3">
            <h3 class="text-white font-semibold">Historical Data</h3>
            <div class="flex space-x-2">
              <button id="copy-historical-data" class="glass-button px-3 py-1 bg-blue-500/20 text-blue-300 hover:bg-blue-500/30 text-xs flex items-center space-x-1" title="Copy historical data to clipboard">
                <svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
                </svg>
                <span>Copy</span>
              </button>
              <button id="clear-historical-data" class="glass-button px-3 py-1 bg-red-500/20 text-red-300 hover:bg-red-500/30 text-xs flex items-center space-x-1" title="Clear historical data">
                <svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                </svg>
                <span>Clear</span>
              </button>
            </div>
          </div>
          <div class="text-xs text-white/60 mb-2">
            Performance data from the last 10 health checks (JSON format)
          </div>
          <pre id="historical-data" class="text-xs text-purple-400 whitespace-pre-wrap overflow-x-auto max-h-32">Historical performance data will appear here...</pre>
        </div>
      </div>

    </div>



  </div>
</MainLayout>

<script>
  // =============================================================================
  // COMPREHENSIVE SYSTEM HEALTH DASHBOARD - TYPESCRIPT (SOLID/DRY PRINCIPLES)
  // =============================================================================
  // Single source of truth for all service checking logic
  // Perfect SOLID implementation with dependency inversion
  // =============================================================================

  // =============================================================================
  // CORE INTERFACES AND TYPES (Interface Segregation Principle)
  // =============================================================================

  type ServiceStatus = 'up' | 'degraded' | 'down' | 'error';

  interface IServiceResult {
    status: ServiceStatus;
    message: string;
    metrics: { responseTime?: number; [key: string]: any };
    error?: string;
    timestamp: number;
  }

  interface ISystemStats {
    totalRequests: number;
    avgResponseTime: number;
    errorRate: number;
    uptime: string;
  }

  interface IServiceChecker {
    readonly serviceName: string;
    readonly endpoint: string;
    checkHealth(): Promise<IServiceResult>;
    updateUI(result: IServiceResult): void;
  }

  interface IPerformanceData {
    timestamp: number;
    responseTime: number;
    service: string;
    status: ServiceStatus;
  }

  // =============================================================================
  // SHARED CONFIGURATION (DRY Principle)
  // =============================================================================

  // Environment detection for optimal configuration
  const ENVIRONMENT = import.meta.env.MODE || import.meta.env.NODE_ENV || 'development';
  const IS_PRODUCTION = ENVIRONMENT === 'production';

  const CONFIG = {
    API_BASE_URL: import.meta.env.PUBLIC_API_URL || import.meta.env.VITE_API_URL || 'http://localhost:8000',
    REQUEST_TIMEOUT: IS_PRODUCTION ? 6000 : 15000, // More generous timeout for development
    // Development vs Production timing configuration:
    // - Development: 60 seconds - more relaxed for debugging and testing
    // - Production: 30 seconds - industry standard for monitoring dashboards
    AUTO_REFRESH_INTERVAL: IS_PRODUCTION ? 30000 : 60000, // 60s dev, 30s prod
    PERFORMANCE_HISTORY_LIMIT: 10,
    ENVIRONMENT,
    STATUS_COLORS: {
      up: 'bg-green-500',
      degraded: 'bg-yellow-500',
      down: 'bg-red-500',
      error: 'bg-gray-500'
    },
    STATUS_TEXT_COLORS: {
      up: 'text-green-400',
      degraded: 'text-yellow-400',
      down: 'text-red-400',
      error: 'text-gray-400'
    }
  } as const;

  // =============================================================================
  // BUTTON FACTORY (DRY Principle - eliminates duplicate button HTML)
  // =============================================================================

  class ButtonFactory {
    static createGlassButton(type: 'copy' | 'clear', id: string, title: string): string {
      const colors = type === 'copy' 
        ? 'bg-blue-500/20 text-blue-300 hover:bg-blue-500/30'
        : 'bg-red-500/20 text-red-300 hover:bg-red-500/30';
      
      const icon = type === 'copy'
        ? 'M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z'
        : 'M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16';
      
      const text = type === 'copy' ? 'Copy' : 'Clear';
      
      return `
        <button id="${id}" class="glass-button px-3 py-1 ${colors} text-xs flex items-center space-x-1" title="${title}">
          <svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="${icon}" />
          </svg>
          <span>${text}</span>
        </button>
      `;
    }
  }

  // =============================================================================
  // UI UPDATER UTILITY CLASS (Single Responsibility Principle)
  // =============================================================================

  class UIUpdater {
    static updateElement(elementId: string, content: string, className?: string): void {
      const element = document.getElementById(elementId);
      if (!element) return;
      
      element.innerHTML = content;
      if (className) {
        element.className = className;
      }
    }

    static updateTextElement(elementId: string, text: string, status?: ServiceStatus): void {
      const element = document.getElementById(elementId);
      if (!element) return;
      
      element.textContent = text;
      if (status) {
        const colorClass = CONFIG.STATUS_TEXT_COLORS[status];
        element.className = `${element.className.replace(/text-\w+-\d+/g, '')} ${colorClass}`.trim();
      }
    }

    static updateStatusIndicator(elementId: string, status: ServiceStatus): void {
      const element = document.getElementById(elementId);
      if (!element) return;
      
      // Remove existing status classes and animation
      element.className = element.className
        .replace(/bg-\w+-\d+/g, '')
        .replace(/animate-pulse/g, '')
        .trim();
      
      // Add new status color
      element.classList.add(CONFIG.STATUS_COLORS[status]);
    }
  }

  // =============================================================================
  // TIMESTAMP UPDATER (Single Responsibility + DRY)
  // =============================================================================
  
  class TimestampUpdater {
    static updateLastRefresh(elementId: string): void {
      UIUpdater.updateTextElement(elementId, new Date().toLocaleTimeString());
    }

    static formatTimestamp(timestamp: Date): string {
      return timestamp.toLocaleTimeString();
    }
  }

  // =============================================================================
  // LATENCY COLORIZER (Performance-Based Visual Feedback)
  // =============================================================================
  
  class LatencyColorizer {
    private static readonly THRESHOLDS = {
      API: { excellent: 50, good: 150, poor: 500 },      // Frontend ‚Üî Backend API
      DATABASE: { excellent: 10, good: 50, poor: 200 },  // Backend ‚Üî Database  
      CACHE: { excellent: 1, good: 5, poor: 20 }         // Backend ‚Üî Cache (Redis)
    };

    static getLatencyStatus(latencyMs: number, type: 'API' | 'DATABASE' | 'CACHE'): string {
      const thresholds = this.THRESHOLDS[type];
      
      if (latencyMs <= thresholds.excellent) return 'up';        // Green
      if (latencyMs <= thresholds.good) return 'degraded';       // Yellow  
      return 'error';                                            // Red
    }

    static updateLatencyElement(elementId: string, latencyText: string, latencyMs: number, type: 'API' | 'DATABASE' | 'CACHE'): void {
      const status = this.getLatencyStatus(latencyMs, type);
      UIUpdater.updateTextElement(elementId, latencyText, status);
      
      // Clean latency update without verbose debug output
    }

    // DRY: Single method to update all latency displays from health data
    static updateAllLatencyFromHealthData(healthData: any, apiLatency: number): void {
      // Frontend ‚Üî Backend API latency
      this.updateLatencyElement('fe-be-latency', `${apiLatency}ms`, apiLatency, 'API');
      
      // Backend ‚Üî Database latency  
      const dbResponseTime = healthData.database?.response_time_ms;
      if (dbResponseTime !== undefined) {
        this.updateLatencyElement('be-db-query', `${dbResponseTime}ms`, dbResponseTime, 'DATABASE');
      } else {
        UIUpdater.updateTextElement('be-db-query', 'No data', 'degraded');
      }
      
      // Backend ‚Üî Cache latency
      const cacheHealthy = healthData.cache?.status === 'healthy';
      if (cacheHealthy) {
        this.updateLatencyElement('be-cache-ping', '<1ms', 0.5, 'CACHE');
      } else {
        UIUpdater.updateTextElement('be-cache-ping', 'Failed', 'error');
      }
    }
  }

  // =============================================================================
  // TIMEZONE UTILITY - DRY/SOLID: Use centralized timezone utility
  // =============================================================================

  import {
    getCurrentTimezone,
    formatTimestamp,
    formatRelativeTime,
    getTimezoneAbbreviation,
    getTimezoneInfo
  } from '../utils/timezone.js';

  // =============================================================================
  // GLOBAL HEALTH DATA CONSUMER (Single Responsibility + DRY Principle)
  // Connect to existing RealtimeHealthEnhancer instead of making duplicate API calls
  // =============================================================================

  interface IHealthDataConsumer {
    getLatestHealthData(): {services: any, overallStatus: any, timestamp: number} | null;
    requestRefresh(): void;
  }

  class GlobalHealthDataConsumer implements IHealthDataConsumer {
    private latestHealthData: {services: any, overallStatus: any, timestamp: number} | null = null;
    private eventListenerAttached = false;

    constructor() {
      this.attachEventListener();
    }

    private attachEventListener(): void {
      if (this.eventListenerAttached) return;
      
      // Listen to the global health updates from RealtimeHealthEnhancer
      window.addEventListener('consolidatedHealthUpdate', (event: any) => {
        this.latestHealthData = event.detail;
        console.log('üéØ GlobalHealthDataConsumer: Received health update', this.latestHealthData);
      });
      
      this.eventListenerAttached = true;
    }

    getLatestHealthData(): {services: any, overallStatus: any, timestamp: number} | null {
      return this.latestHealthData;
    }

    // Request manual refresh by triggering global health refresh
    requestRefresh(): void {
      // Dispatch event to request global health refresh
      window.dispatchEvent(new CustomEvent('requestHealthRefresh'));
    }
  }

  // =============================================================================
  // BASE SERVICE CHECKER CLASS (Open/Closed Principle)
  // =============================================================================

  abstract class BaseServiceChecker implements IServiceChecker {
    abstract readonly serviceName: string;
    abstract readonly endpoint: string;
    
    // Dependency Injection: Accept health data consumer to eliminate duplicate fetches
    constructor(protected healthDataConsumer?: IHealthDataConsumer) {}

    protected async fetchWithTimeout(url: string, timeout: number = CONFIG.REQUEST_TIMEOUT): Promise<Response> {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), timeout);
      
      try {
        const response = await fetch(url, {
          method: 'GET',
          headers: { 'Accept': 'application/json' },
          signal: controller.signal
        });
        clearTimeout(timeoutId);
        return response;
      } catch (error) {
        clearTimeout(timeoutId);
        throw error;
      }
    }

    protected createResult(status: ServiceStatus, message: string, metrics: any, error?: string): IServiceResult {
      return {
        status,
        message,
        metrics,
        error,
        timestamp: Date.now()
      };
    }

    protected handleError(error: Error): IServiceResult {
      const isTimeout = error.name === 'AbortError' || error.message.includes('timeout');
      const isNetworkError = error.message.includes('fetch') || error.message.includes('network');
      
      return this.createResult(
        'error',
        `${this.serviceName} Error: ${isTimeout ? 'Timeout' : isNetworkError ? 'Network Error' : error.message}`,
        {},
        error.message
      );
    }

    abstract checkHealth(): Promise<IServiceResult>;
    abstract updateUI(result: IServiceResult): void;
  }

  // =============================================================================
  // CONCRETE SERVICE CHECKER IMPLEMENTATIONS (Liskov Substitution Principle)
  // =============================================================================

  class BackendServiceChecker extends BaseServiceChecker {
    readonly serviceName = 'Backend';
    readonly endpoint = `${CONFIG.API_BASE_URL}/health/`;

    async checkHealth(): Promise<IServiceResult> {
      // Use global health data consumer (DRY principle - eliminates duplicate fetches)
      if (this.healthDataConsumer) {
        const globalHealthData = this.healthDataConsumer.getLatestHealthData();
        
        if (globalHealthData && globalHealthData.services.backend) {
          const backendData = globalHealthData.services.backend;
          return this.createResult(
            backendData.status,
            backendData.message,
            backendData.metrics || {}
          );
        }
      }
      
      // Fallback to direct fetch if no aggregator provided
      try {
        const startTime = Date.now();
        const response = await this.fetchWithTimeout(this.endpoint);
        const responseTime = Date.now() - startTime;
        
        if (response.ok) {
          const data = await response.json();
          return this.createResult(
            data.status === 'healthy' ? 'up' : 'degraded',
            `Backend ${data.status}`,
            { responseTime, ...data }
          );
        } else {
          return this.createResult('error', `Backend HTTP ${response.status}`, { responseTime });
        }
      } catch (error) {
        return this.handleError(error as Error);
      }
    }

    updateUI(result: IServiceResult): void {
      UIUpdater.updateStatusIndicator('backend-status-indicator', result.status);
      UIUpdater.updateTextElement('backend-status-text', result.message, result.status);
      
      // Update last refreshed timestamp
      const now = new Date();
      const timeString = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
      UIUpdater.updateTextElement('backend-last-refreshed', `Last checked: ${timeString}`);
      
      // Note: backend-uptime, backend-version, backend-memory, backend-cpu 
      // are now handled by the dedicated backend-metrics.ts script
      
      // Component status indicators are now handled by the dedicated backend-metrics.ts script
      // Note: Removed duplicate component updates to prevent conflicts

      // Monitoring services are now quick access buttons

      // Update raw data display
      UIUpdater.updateElement('raw-backend-data', JSON.stringify(result, null, 2));
    }

  }

  class PostgresServiceChecker extends BaseServiceChecker {
    readonly serviceName = 'PostgreSQL';
    readonly endpoint = `${CONFIG.API_BASE_URL}/health/`;

    async checkHealth(): Promise<IServiceResult> {
      // Use global health data consumer (DRY principle - eliminates duplicate fetches)
      if (this.healthDataConsumer) {
        const globalHealthData = this.healthDataConsumer.getLatestHealthData();
        
        if (globalHealthData && globalHealthData.services.database) {
          const databaseData = globalHealthData.services.database;
          return this.createResult(
            databaseData.status,
            databaseData.message,
            databaseData.metrics || {}
          );
        }
      }
      
      // Fallback to direct fetch if no aggregator provided
      try {
        const startTime = Date.now();
        const response = await this.fetchWithTimeout(this.endpoint);
        const responseTime = Date.now() - startTime;
        
        if (response.ok) {
          const data = await response.json();
          const dbData = data.database || {};
          
          return this.createResult(
            dbData.status === 'healthy' ? 'up' : 'down',
            `Database ${dbData.status || 'unknown'}`,
            { 
              responseTime,
              connected: dbData.connected,
              response_time_ms: dbData.response_time_ms,
              active_connections: dbData.active_connections,
              avg_query_time: dbData.avg_query_time,
              cache_hit_ratio: dbData.cache_hit_ratio
            }
          );
        } else {
          return this.createResult('error', `Database HTTP ${response.status}`, { responseTime });
        }
      } catch (error) {
        return this.handleError(error as Error);
      }
    }

    updateUI(result: IServiceResult): void {
      UIUpdater.updateStatusIndicator('postgres-status-indicator', result.status);
      UIUpdater.updateTextElement('postgres-status-text', result.message, result.status);
      
      // Update last refreshed timestamp
      const now = new Date();
      const timeString = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
      UIUpdater.updateTextElement('postgres-last-refreshed', `Last checked: ${timeString}`);
      
      UIUpdater.updateTextElement('postgres-active-connections', String(result.metrics.active_connections || 0));
      UIUpdater.updateTextElement('postgres-query-time', `${result.metrics.avg_query_time || 0}ms`);
      UIUpdater.updateTextElement('postgres-cache-hit', `${result.metrics.cache_hit_ratio || 0}%`);
    }
  }

  class RedisServiceChecker extends BaseServiceChecker {
    readonly serviceName = 'Redis';
    readonly endpoint = `${CONFIG.API_BASE_URL}/health/`;

    async checkHealth(): Promise<IServiceResult> {
      // Use global health data consumer (DRY principle - eliminates duplicate fetches)
      if (this.healthDataConsumer) {
        const globalHealthData = this.healthDataConsumer.getLatestHealthData();
        
        if (globalHealthData && globalHealthData.services.cache) {
          const cacheData = globalHealthData.services.cache;
          return this.createResult(
            cacheData.status,
            cacheData.message,
            cacheData.metrics || {}
          );
        }
      }
      
      // Fallback to direct fetch if no aggregator provided
      try {
        const startTime = Date.now();
        const response = await this.fetchWithTimeout(this.endpoint);
        const responseTime = Date.now() - startTime;
        
        if (response.ok) {
          const data = await response.json();
          const cacheData = data.cache || {};
          
          return this.createResult(
            cacheData.status === 'healthy' ? 'up' : 'down',
            `Cache ${cacheData.status || 'unknown'}`,
            { 
              responseTime,
              backend: cacheData.backend,
              memory_used: cacheData.memory_used,
              hit_rate: cacheData.hit_rate
            }
          );
        } else {
          return this.createResult('error', `Cache HTTP ${response.status}`, { responseTime });
        }
      } catch (error) {
        return this.handleError(error as Error);
      }
    }

    updateUI(result: IServiceResult): void {
      UIUpdater.updateStatusIndicator('redis-status-indicator', result.status);
      UIUpdater.updateTextElement('redis-status-text', result.message, result.status);
      
      // Update last refreshed timestamp
      const now = new Date();
      const timeString = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
      UIUpdater.updateTextElement('redis-last-refreshed', `Last checked: ${timeString}`);
      
      UIUpdater.updateTextElement('redis-memory-used', result.metrics.memory_used || 'Unknown');
      UIUpdater.updateTextElement('redis-hit-rate', result.metrics.hit_rate || 'Unknown');
      UIUpdater.updateTextElement('redis-config-test', result.status === 'up' ? '‚úÖ Configuration OK' : '‚ùå Configuration Failed');
    }
  }

  class FrontendServiceChecker extends BaseServiceChecker {
    readonly serviceName = 'Frontend';
    readonly endpoint = 'self'; // Frontend checks itself

    async checkHealth(): Promise<IServiceResult> {
      // Use global health data consumer if available
      if (this.healthDataConsumer) {
        const globalHealthData = this.healthDataConsumer.getLatestHealthData();
        
        if (globalHealthData && globalHealthData.services.frontend) {
          const frontendData = globalHealthData.services.frontend;
          return this.createResult(
            frontendData.status,
            frontendData.message,
            frontendData.metrics || {}
          );
        }
      }
      
      // Fallback: Frontend is operational if this code executes
      return this.createResult(
        'up',
        'Frontend OPERATIONAL',
        {
          responseTime: 0,
          framework: 'Astro v5.13.6',
          port: 3000,
          environment: 'Development',
          bundleSize: '~2.1MB'
        }
      );
    }

    updateUI(result: IServiceResult): void {
      UIUpdater.updateStatusIndicator('frontend-status-indicator', result.status);
      UIUpdater.updateTextElement('frontend-status-text', result.message, result.status);
      UIUpdater.updateTextElement('frontend-load-time', `${result.metrics.responseTime}ms`);
      
      // Update last refreshed timestamp
      const now = new Date();
      const timeString = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
      UIUpdater.updateTextElement('frontend-last-refreshed', `Last checked: ${timeString}`);
      
      // Performance metrics (using Performance API if available)
      if (performance.memory) {
        UIUpdater.updateTextElement('frontend-memory', `${Math.round(performance.memory.usedJSHeapSize / 1024 / 1024)}MB`);
      }
    }
  }

  // Grafana and Prometheus service checkers moved to serviceCheckers.ts

  // =============================================================================
  // PERFORMANCE MONITORING SYSTEM (Single Responsibility)
  // =============================================================================

  class PerformanceMonitor {
    private performanceHistory: IPerformanceData[] = [];
    private systemStats: ISystemStats = {
      totalRequests: 0,
      avgResponseTime: 0,
      errorRate: 0,
      uptime: '0s'
    };

    addPerformanceData(data: IPerformanceData): void {
      this.performanceHistory.push(data);
      if (this.performanceHistory.length > CONFIG.PERFORMANCE_HISTORY_LIMIT) {
        this.performanceHistory.shift();
      }
      this.updateSystemStats();
      this.updatePerformanceChart();
    }

    private updateSystemStats(): void {
      const history = this.performanceHistory;
      if (history.length === 0) return;

      this.systemStats.totalRequests = history.length;
      this.systemStats.avgResponseTime = Math.round(
        history.reduce((sum, d) => sum + d.responseTime, 0) / history.length
      );
      
      const errorCount = history.filter(d => d.status === 'error' || d.status === 'down').length;
      this.systemStats.errorRate = Math.round((errorCount / history.length) * 100);
      
      // Calculate uptime (simplified)
      const oldestTimestamp = Math.min(...history.map(d => d.timestamp));
      const uptimeMs = Date.now() - oldestTimestamp;
      this.systemStats.uptime = `${Math.round(uptimeMs / 1000)}s`;

      // Update UI
      UIUpdater.updateTextElement('total-requests', String(this.systemStats.totalRequests));
      UIUpdater.updateTextElement('avg-response-time', `${this.systemStats.avgResponseTime}ms`);
      UIUpdater.updateTextElement('error-rate', `${this.systemStats.errorRate}%`);
    }

    private updatePerformanceChart(): void {
      const chartElement = document.getElementById('performance-chart');
      if (!chartElement) return;

      const maxHeight = 60; // pixels
      const maxTime = Math.max(...this.performanceHistory.map(d => d.responseTime), 100);

      const bars = this.performanceHistory.map(data => {
        const height = Math.max((data.responseTime / maxTime) * maxHeight, 2);
        const color = data.status === 'up' ? 'green' : 
                     data.status === 'degraded' ? 'yellow' : 
                     data.status === 'down' ? 'red' : 'orange';
        
        const colorClass = color === 'green' ? 'bg-green-400' :
                          color === 'yellow' ? 'bg-yellow-400' :
                          color === 'red' ? 'bg-red-400' :
                          color === 'orange' ? 'bg-orange-400' : 'bg-red-400';
        
        return `<div class="flex-1 ${colorClass} mx-px rounded-t" style="height: ${height}px" title="${data.service}: ${data.responseTime}ms"></div>`;
      }).join('');

      chartElement.innerHTML = bars || '<div class="text-white/40 text-center w-full">Performance data will appear here after tests</div>';
    }

    getHistoricalData(): string {
      const historyWithTimezone = {
        timezone: getCurrentTimezone(),
        timezoneAbbreviation: getTimezoneAbbreviation(),
        lastUpdated: formatTimestamp(new Date()),
        data: this.performanceHistory.map(entry => ({
          ...entry,
          formattedTimestamp: formatTimestamp(new Date(entry.timestamp)),
          relativeTime: formatRelativeTime(entry.timestamp)
        }))
      };
      return JSON.stringify(historyWithTimezone, null, 2);
    }

    clearData(): void {
      this.performanceHistory = [];
      this.systemStats = { totalRequests: 0, avgResponseTime: 0, errorRate: 0, uptime: '0s' };
      this.updateSystemStats();
      this.updatePerformanceChart();
    }

    // Alias for clearData - used by the clear historical data button
    clearHistory(): void {
      this.clearData();
    }
  }

  // =============================================================================
  // DEBUG LOGGER SYSTEM (Single Responsibility)
  // =============================================================================

  class DebugLogger {
    private static logs: string[] = [];

    static log(message: string, type: 'info' | 'success' | 'error' | 'warning' = 'info'): void {
      const timestamp = new Date().toLocaleTimeString();
      const icon = type === 'success' ? '‚úÖ' : 
                   type === 'error' ? '‚ùå' : 
                   type === 'warning' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è';
      
      const logEntry = `[${timestamp}] ${icon} ${message}`;
      this.logs.push(logEntry);
      
      // Show debug section
      const debugSection = document.getElementById('debug-output');
      if (debugSection) {
        debugSection.style.display = 'block';
      }
      
      // Update content
      this.updateDebugContent();
    }

    static clear(): void {
      this.logs = [];
      this.updateDebugContent();
      
      // Hide debug section if no logs
      const debugSection = document.getElementById('debug-output');
      if (debugSection && this.logs.length === 0) {
        debugSection.style.display = 'none';
      }
    }

    static getAllLogs(): string[] {
      return [...this.logs]; // Return copy to prevent mutation
    }

    private static updateDebugContent(): void {
      const debugContent = document.getElementById('debug-content');
      if (debugContent) {
        if (this.logs.length === 0) {
          debugContent.innerHTML = '<div class="text-green-400 text-xs font-mono">Debug output will appear here after running tests...</div>';
        } else {
          debugContent.innerHTML = this.logs
            .slice(-20) // Show last 20 logs
            .map(log => `<div class="text-green-400 text-xs font-mono mb-1">${log}</div>`)
            .join('');
          
          // Auto-scroll to bottom
          debugContent.scrollTop = debugContent.scrollHeight;
        }
      }
    }

    static logFetchAttempt(method: string, url: string, headers?: HeadersInit): void {
      const headerStr = headers ? JSON.stringify(headers, null, 2) : 'none';
      this.log(`üåê FETCH: ${method} ${url}\n   Headers: ${headerStr}`, 'info');
    }

    static logFetchResponse(response: Response, latency?: number): void {
      const latencyStr = latency ? ` (${latency}ms)` : '';
      if (response.ok) {
        this.log(`‚úÖ RESPONSE: ${response.status} ${response.statusText}${latencyStr}`, 'success');
      } else {
        this.log(`‚ùå RESPONSE: ${response.status} ${response.statusText}${latencyStr}`, 'error');
      }
    }

    static logFetchError(error: any): void {
      this.log(`üö´ FETCH ERROR: ${error.message || error}`, 'error');
    }
  }

  // =============================================================================
  // AUTO-REFRESH SYSTEM (Single Responsibility)
  // =============================================================================

  class AutoRefreshManager {
    private isEnabled = false;
    private intervalId: number | null = null;
    private readonly healthDashboard: HealthDashboard;

    constructor(healthDashboard: HealthDashboard) {
      this.healthDashboard = healthDashboard;
    }

    toggle(): void {
      if (this.isEnabled) {
        this.disable();
      } else {
        this.enable();
      }
    }

    private enable(): void {
      this.isEnabled = true;
      
      // Only auto-refresh system performance metrics - connectivity tests are on-demand only
      this.intervalId = window.setInterval(() => {
        this.healthDashboard.refreshAllServices();
      }, CONFIG.AUTO_REFRESH_INTERVAL);
      
      UIUpdater.updateTextElement('toggle-auto-refresh', '‚èπÔ∏è Disable Auto-Refresh');
    }

    private disable(): void {
      this.isEnabled = false;
      
      // Clear main services interval
      if (this.intervalId) {
        clearInterval(this.intervalId);
        this.intervalId = null;
      }
      
      UIUpdater.updateTextElement('toggle-auto-refresh', '‚è±Ô∏è Enable Auto-Refresh');
    }
  }

  // =============================================================================
  // CONNECTIVITY TESTER (Single Responsibility)
  // =============================================================================

  class ConnectivityTester {
    // Single responsibility: CORS testing logic (DRY principle)
    private async testSingleServiceCORS(serviceName: string, url: string, expectedBlocked: boolean): Promise<{corsAllowed: boolean, latency: number, error?: string}> {
      try {
        const startTime = performance.now();
        const response = await fetch(url, {
          method: 'GET',
          headers: { 'Origin': window.location.origin },
          mode: 'cors'
        });
        const latency = Math.round(performance.now() - startTime);
        
        return {
          corsAllowed: response.ok,
          latency: latency
        };
      } catch (error) {
        return {
          corsAllowed: false,
          latency: 0,
          error: error instanceof Error ? error.message : 'Unknown error'
        };
      }
    }

    // Single responsibility: CORS status message generation (DRY principle)
    private getCORSStatusMessage(serviceName: string, corsAllowed: boolean, expectedBlocked: boolean): string {
      // Use comprehensive messaging that matches testCORSPolicies() for consistency (DRY principle)
      if (serviceName === 'Backend API') {
        // Backend API should allow CORS for frontend communication
        return corsAllowed ? 'CONFIGURED (allows API access)' : 'MISCONFIGURED (blocks API access)';
      } else {
        // Monitoring services should block CORS for security best practices
        return corsAllowed ? 'INSECURE (allows browser access)' : 'SECURE (blocks browser access)';
      }
    }

    // DRY: Calculate CORS security status (used by both page load and manual test)
    private getCORSSecurityStatus(apiAllowed: boolean, monitoringBlocked: number): { status: string, type: 'up' | 'error' | 'degraded' } {
      if (apiAllowed && monitoringBlocked >= 2) {
        return { status: 'CORS Secure ‚úÖ', type: 'up' };
      } else if (apiAllowed && monitoringBlocked >= 1) {
        return { status: 'CORS Good ‚úÖ', type: 'up' };
      } else if (!apiAllowed) {
        return { status: 'API Blocked ‚ö†Ô∏è', type: 'error' };
      } else {
        return { status: 'Mixed Config ‚ö†Ô∏è', type: 'degraded' };
      }
    }

    // DRY: Single method to test Backend API CORS (used by both page load and manual test)
    private async testBackendAPICORS(): Promise<void> {
      UIUpdater.updateTextElement('fe-be-status', 'Testing...', 'degraded');
      
      const backendTest = await this.testSingleServiceCORS('Backend API', `${CONFIG.API_BASE_URL}/health/`, false);
      
      if (backendTest.error) {
        UIUpdater.updateTextElement('fe-be-status', 'Error', 'error');
        UIUpdater.updateTextElement('fe-be-latency', 'Failed', 'error');
        UIUpdater.updateTextElement('fe-be-cors', 'Failed', 'error');
      } else {
        UIUpdater.updateTextElement('fe-be-status', backendTest.corsAllowed ? 'Connected' : 'Failed', backendTest.corsAllowed ? 'up' : 'error');
        LatencyColorizer.updateLatencyElement('fe-be-latency', `${backendTest.latency}ms`, backendTest.latency, 'API');
        
        // DRY: Use same rich status as manual test (assume monitoring services are properly blocked)
        const corsStatus = this.getCORSSecurityStatus(backendTest.corsAllowed, 2);
        UIUpdater.updateTextElement('fe-be-cors', corsStatus.status, corsStatus.type);
      }
    }

    // Single responsibility: Shared health endpoint fetching (DRY principle)
    private async fetchHealthData(): Promise<{success: boolean, data?: any, error?: string, responseTime?: number}> {
      try {
        const startTime = Date.now();
        const response = await fetch(`${CONFIG.API_BASE_URL}/health/`);
        const responseTime = Date.now() - startTime;
        
        if (response.ok) {
          const data = await response.json();
          return { success: true, data, responseTime };
        } else {
          return { success: false, error: `HTTP ${response.status}: ${response.statusText}`, responseTime };
        }
      } catch (error) {
        return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
      }
    }

    // Single responsibility: Parse health data for specific service (SOLID principle)
    private parseHealthService(healthData: any, serviceType: 'backend' | 'database' | 'cache', responseTime: number): IServiceResult {
      if (serviceType === 'backend') {
        const status = healthData.status === 'healthy' ? 'up' : 'down';
        return {
          status,
          message: `Backend API ${healthData.status || 'unknown'}`,
          metrics: { 
            responseTime,
            uptime: healthData.uptime,
            version: healthData.version,
            environment: healthData.environment 
          },
          timestamp: Date.now()
        };
      } else if (serviceType === 'database') {
        const dbData = healthData.database || {};
        const status = dbData.status === 'healthy' ? 'up' : 'down';
        return {
          status,
          message: `Database ${dbData.status || 'unknown'}`,
          metrics: { 
            responseTime,
            connected: dbData.connected,
            response_time_ms: dbData.response_time_ms,
            active_connections: dbData.active_connections,
            avg_query_time: dbData.avg_query_time,
            cache_hit_ratio: dbData.cache_hit_ratio
          },
          timestamp: Date.now()
        };
      } else if (serviceType === 'cache') {
        const cacheData = healthData.cache || {};
        const status = cacheData.status === 'healthy' ? 'up' : 'down';
        return {
          status,
          message: `Cache ${cacheData.status || 'unknown'}`,
          metrics: { 
            responseTime,
            backend: cacheData.backend,
            memory_used: cacheData.memory_used,
            hit_rate: cacheData.hit_rate
          },
          timestamp: Date.now()
        };
      }
      
      return {
        status: 'error',
        message: 'Unknown service type',
        metrics: {},
        timestamp: Date.now()
      };
    }

    async testFrontendBackendLatency(): Promise<void> {
      // Use shared health endpoint fetching (DRY principle)
      const startTime = Date.now();
      const result = await this.fetchHealthData();
      const latency = Date.now() - startTime;
      
      if (result.success) {
        UIUpdater.updateTextElement('fe-be-status', 'Connected', 'up');
        LatencyColorizer.updateLatencyElement('fe-be-latency', `${latency}ms`, latency, 'API');
      } else {
        UIUpdater.updateTextElement('fe-be-status', result.error?.includes('timeout') ? 'Timeout' : 'Failed', 'error');
        UIUpdater.updateTextElement('fe-be-latency', 'Failed', 'error');
      }
    }

    async testNetworkConnectivity(): Promise<void> {
      // DRY: Use centralized Backend API CORS testing (eliminates duplicate logic)
      await this.testBackendAPICORS();

      // Backend ‚Üî Database & Cache (using shared health endpoint - DRY principle)
      UIUpdater.updateTextElement('be-db-status', 'Testing...', 'degraded');
      UIUpdater.updateTextElement('be-cache-status', 'Testing...', 'degraded');
      
      // Single fetch for both database and cache health (eliminates duplicate API calls)
      const healthResult = await this.fetchHealthData();
      
      if (healthResult.success && healthResult.data) {
        // Database status from shared health response
        const dbConnected = healthResult.data.database?.connected;
        UIUpdater.updateTextElement('be-db-status', dbConnected ? 'Connected' : 'Failed', dbConnected ? 'up' : 'error');
        
        // Cache status from shared health response  
        const cacheHealthy = healthResult.data.cache?.status === 'healthy';
        UIUpdater.updateTextElement('be-cache-status', cacheHealthy ? 'Connected' : 'Failed', cacheHealthy ? 'up' : 'error');
        
        // DRY: Use centralized latency update method (eliminates code duplication)
        const apiLatency = healthResult.responseTime || 0;
        LatencyColorizer.updateAllLatencyFromHealthData(healthResult.data, apiLatency);
      } else {
        // Handle shared error for both services
        const errorType = healthResult.error?.includes('timeout') ? 'Timeout' : 'Error';
        UIUpdater.updateTextElement('be-db-status', errorType, 'error');
        UIUpdater.updateTextElement('be-db-query', 'Failed');
        UIUpdater.updateTextElement('be-cache-status', errorType, 'error');
        UIUpdater.updateTextElement('be-cache-ping', 'Failed');
      }
      
      // Update connectivity panel timestamp (DRY: reusable timestamp pattern)
      TimestampUpdater.updateLastRefresh('connectivity-last-update');
    }

    // Test CORS policies across all services
    async testCORSPolicies(): Promise<void> {
      DebugLogger.log('üß™ Starting CORS Policy Test', 'info');
      
      // DRY: Use centralized Backend API CORS testing (eliminates duplicate logic)
      await this.testBackendAPICORS();
      
      // Additional monitoring services to test (Backend API is handled above)
      const monitoringServices = [
        { 
          name: 'Prometheus', 
          url: 'http://localhost:9090/api/v1/query?query=up', 
          elementPrefix: 'prometheus',
          expectedBlocked: true,
          description: 'Should block direct browser access (security best practice)'
        },
        { 
          name: 'Grafana', 
          url: 'http://localhost:3001/api/health', 
          elementPrefix: 'grafana',
          expectedBlocked: true,
          description: 'Should block direct browser access (security best practice)'
        }
      ];

      let configurationCorrect = true;
      const results: string[] = [];
      let apiAllowed = true; // Backend API handled above, assume it worked
      let monitoringBlocked = 0;

      for (const service of monitoringServices) {
        DebugLogger.log(`üîç Testing CORS for ${service.name}`, 'info');
        DebugLogger.log(`   Expected: ${service.expectedBlocked ? 'BLOCKED' : 'ALLOWED'}`, 'info');
        
        try {
          // Use shared CORS testing logic (DRY principle)
          DebugLogger.logFetchAttempt('GET', service.url, { 'Origin': window.location.origin });
          
          const testResult = await this.testSingleServiceCORS(service.name, service.url, service.expectedBlocked);
          
          if (testResult.error) {
            throw new Error(testResult.error);
          }
          
          DebugLogger.logFetchResponse({ ok: testResult.corsAllowed, status: testResult.corsAllowed ? 200 : 400, statusText: testResult.corsAllowed ? 'OK' : 'Failed' } as Response, testResult.latency);

          const corsAllowed = testResult.corsAllowed;
          const isCorrectConfiguration = service.expectedBlocked ? !corsAllowed : corsAllowed;
          
          DebugLogger.log(`   CORS Result: ${corsAllowed ? 'ALLOWED' : 'BLOCKED'}`, corsAllowed ? 'success' : 'warning');
          DebugLogger.log(`   Configuration: ${isCorrectConfiguration ? 'CORRECT' : 'INCORRECT'}`, isCorrectConfiguration ? 'success' : 'error');
          
          if (!isCorrectConfiguration) {
            configurationCorrect = false;
          }

          // Track monitoring service blocking (Backend API handled separately above)
          if (!corsAllowed) {
            monitoringBlocked++;
          }

          // Create result message based on expected behavior
          const statusIcon = isCorrectConfiguration ? '‚úÖ' : '‚ö†Ô∏è';
          const statusText = service.expectedBlocked 
            ? (corsAllowed ? 'INSECURE (allows browser access)' : 'SECURE (blocks browser access)')
            : (corsAllowed ? 'CONFIGURED (allows API access)' : 'MISCONFIGURED (blocks API access)');
          
          results.push(`${statusIcon} ${service.name}: ${statusText}`);
          
          // Update specific UI elements if they exist
          const corsElement = document.getElementById(`${service.elementPrefix}-cors`);
          if (corsElement) {
            const displayText = service.expectedBlocked 
              ? (corsAllowed ? 'Insecure' : 'Secure') 
              : (corsAllowed ? 'Allowed' : 'Blocked');
            const displayStatus = isCorrectConfiguration ? 'up' : 'error';
            
            UIUpdater.updateTextElement(`${service.elementPrefix}-cors`, displayText, displayStatus);
          }
        } catch (error) {
          DebugLogger.logFetchError(error);
          
          // Network errors are expected for monitoring services (they should be blocked)
          monitoringBlocked++;
          results.push(`‚úÖ ${service.name}: SECURE (network blocked)`);
          DebugLogger.log(`   Network blocked (expected for monitoring service)`, 'success');
        }
      }

      // Determine overall status message
      let overallStatus: string;
      let overallType: 'up' | 'error' | 'degraded';
      let summaryMessage: string;

      // DRY: Use centralized CORS security status calculation
      const corsSecurityStatus = this.getCORSSecurityStatus(apiAllowed, monitoringBlocked);
      overallStatus = corsSecurityStatus.status;
      overallType = corsSecurityStatus.type;
      
      // Generate detailed summary message based on status
      if (apiAllowed && monitoringBlocked >= 2) {
        summaryMessage = '‚úÖ CORS Configuration Optimal!\n‚Ä¢ Backend API properly configured for frontend access\n‚Ä¢ Monitoring services secured against direct browser access';
      } else if (apiAllowed && monitoringBlocked >= 1) {
        summaryMessage = '‚úÖ CORS Configuration Good!\n‚Ä¢ Backend API accessible to frontend\n‚Ä¢ Most monitoring services properly secured';
      } else if (!apiAllowed) {
        summaryMessage = '‚ö†Ô∏è CORS Configuration Issue!\n‚Ä¢ Backend API is not accessible to frontend\n‚Ä¢ This will prevent the application from working properly';
      } else {
        summaryMessage = '‚ö†Ô∏è CORS Configuration Mixed\n‚Ä¢ Check individual service configurations\n‚Ä¢ Some services may need security review';
      }

      // Update main CORS status
      UIUpdater.updateTextElement('fe-be-cors', overallStatus, overallType);

      // Show detailed results in notification
      UINotification.show(
        `${summaryMessage}\n\nDetailed Results:\n${results.join('\n')}`,
        overallType === 'up' ? 'success' : overallType === 'error' ? 'error' : 'info'
      );
      
      DebugLogger.log(`üèÅ CORS Test Complete: ${overallStatus}`, overallType === 'up' ? 'success' : 'error');
      
      // Update connectivity panel timestamp (DRY: reusable timestamp pattern)
      TimestampUpdater.updateLastRefresh('connectivity-last-update');
    }

    // Test network latency to all services  
    async testNetworkLatency(): Promise<void> {
      DebugLogger.log('üöÄ Starting Latency Test', 'info');
      
      // Show testing state for all elements
      UIUpdater.updateTextElement('fe-be-latency', 'Testing...', 'degraded');
      UIUpdater.updateTextElement('be-db-query', 'Testing...', 'degraded');
      UIUpdater.updateTextElement('be-cache-ping', 'Testing...', 'degraded');

      try {
        // Use shared health endpoint (same as page load behavior - eliminates inconsistency)
        DebugLogger.log('üì° Fetching health data for latency test', 'info');
        const healthResult = await this.fetchHealthData();
        DebugLogger.log(`üìä Health result: ${JSON.stringify(healthResult)}`, healthResult.success ? 'success' : 'error');
        const results: string[] = [];
        
        if (healthResult.success && healthResult.data) {
          // DRY: Use centralized latency update method (eliminates duplicate logic)
          const apiLatency = healthResult.responseTime || 0;
          DebugLogger.log(`üéØ Starting latency updates: API=${apiLatency}ms`, 'info');
          
          LatencyColorizer.updateAllLatencyFromHealthData(healthResult.data, apiLatency);
          
          // Build results summary
          results.push(`‚úÖ Frontend ‚Üî Backend API: ${apiLatency}ms`);
          
          const dbResponseTime = healthResult.data.database?.response_time_ms;
          if (dbResponseTime !== undefined) {
            results.push(`‚úÖ Backend ‚Üî Database: ${dbResponseTime}ms`);
          } else {
            results.push(`‚ö†Ô∏è Backend ‚Üî Database: No response time data`);
          }
          
          const cacheHealthy = healthResult.data.cache?.status === 'healthy';
          if (cacheHealthy) {
            results.push(`‚úÖ Backend ‚Üî Cache: <1ms (Redis in-memory)`);
          } else {
            results.push(`‚ùå Backend ‚Üî Cache: Connection failed`);
          }
        } else {
          // Handle error case for all services
          const errorMsg = healthResult.error?.includes('timeout') ? 'Timeout' : 'Failed';
          UIUpdater.updateTextElement('fe-be-latency', errorMsg, 'error');
          UIUpdater.updateTextElement('be-db-query', errorMsg, 'error');
          UIUpdater.updateTextElement('be-cache-ping', errorMsg, 'error');
          results.push(`‚ùå All services: ${healthResult.error || 'Health check failed'}`);
        }

        // Log results summary to debug output (no UI notification needed)
        DebugLogger.log(`Latency Test Results: ${results.join(', ')}`, healthResult.success ? 'success' : 'error');
        
      } catch (error) {
        // Fallback error handling
        const errorMsg = 'Error';
        UIUpdater.updateTextElement('fe-be-latency', errorMsg, 'error');
        UIUpdater.updateTextElement('be-db-query', errorMsg, 'error');
        UIUpdater.updateTextElement('be-cache-ping', errorMsg, 'error');
        DebugLogger.log(`Latency Test Error: ${error instanceof Error ? error.message : 'Unknown error'}`, 'error');
      }
      
      // Update connectivity panel timestamp (DRY: reusable timestamp pattern)
      TimestampUpdater.updateLastRefresh('connectivity-last-update');
    }
  }

  // =============================================================================
  // DATA EXPORT SYSTEM (Single Responsibility)
  // =============================================================================

  class DataExporter {
    private readonly performanceMonitor: PerformanceMonitor;
    private readonly healthDashboard: HealthDashboard;

    constructor(performanceMonitor: PerformanceMonitor, healthDashboard: HealthDashboard) {
      this.performanceMonitor = performanceMonitor;
      this.healthDashboard = healthDashboard;
    }

    exportHealthReport(): void {
      const reportData = {
        timestamp: formatTimestamp(new Date()),
        timezone: getCurrentTimezone(),
        services: Array.from(this.healthDashboard.getLatestResults().entries()).map(([service, result]) => ({
          service,
          ...result
        })),
        performance: this.performanceMonitor.getHistoricalData()
      };

      const blob = new Blob([JSON.stringify(reportData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = `health-report-${Date.now()}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    copyRawData(): void {
      const data = this.performanceMonitor.getHistoricalData();
      navigator.clipboard.writeText(data).then(() => {
        UIUpdater.updateTextElement('copy-data', '‚úÖ Copied');
        setTimeout(() => {
          UIUpdater.updateTextElement('copy-data', 'Copy JSON');
        }, 2000);
      }).catch(() => {
        UIUpdater.updateTextElement('copy-data', '‚ùå Failed');
      });
    }
  }

  // =============================================================================
  // MAIN HEALTH DASHBOARD CONTROLLER (Dependency Inversion Principle)
  // =============================================================================

  class HealthDashboard {
    private readonly serviceCheckers: Map<string, IServiceChecker> = new Map();
    private readonly performanceMonitor: PerformanceMonitor;
    private readonly autoRefreshManager: AutoRefreshManager;
    private readonly connectivityTester: ConnectivityTester;
    private readonly dataExporter: DataExporter;
    private readonly healthDataConsumer: IHealthDataConsumer;
    private readonly latestResults: Map<string, IServiceResult> = new Map();
    
    // NEW: Event-driven card monitoring (DRY + Single Source of Truth)
    private readonly cardResults: Map<string, IServiceResult> = new Map();
    private readonly expectedCardServices = ['frontend', 'backend', 'postgres', 'redis'];
    private cardLoadingStarted = false;

    constructor() {
      this.performanceMonitor = new PerformanceMonitor();
      this.autoRefreshManager = new AutoRefreshManager(this);
      this.connectivityTester = new ConnectivityTester();
      this.dataExporter = new DataExporter(this.performanceMonitor, this);
      
      // Initialize global health data consumer (eliminates duplicate API calls)
      this.healthDataConsumer = new GlobalHealthDataConsumer();

      this.initializeServiceCheckers();
      this.bindEventListeners();
      this.initializeLiveClock();
      this.initializeCardBasedMonitoring();
      this.connectToGlobalHealthUpdates();
      this.startInitialChecks();
    }

    private initializeServiceCheckers(): void {
      // Use global health data consumer instead of individual API calls (eliminates rate limiting)
      this.serviceCheckers.set('frontend', new FrontendServiceChecker(this.healthDataConsumer));
      this.serviceCheckers.set('backend', new BackendServiceChecker(this.healthDataConsumer));
      this.serviceCheckers.set('postgres', new PostgresServiceChecker(this.healthDataConsumer));
      this.serviceCheckers.set('redis', new RedisServiceChecker(this.healthDataConsumer));
      // Grafana and Prometheus monitoring moved to Backend service sub-components
    }

    private connectToGlobalHealthUpdates(): void {
      // Listen for global health updates from RealtimeHealthEnhancer
      window.addEventListener('consolidatedHealthUpdate', (event: any) => {
        console.log('üéØ HealthDashboard: Received global health update', event.detail);
        this.updateFromGlobalHealthData(event.detail);
      });

      // Listen for manual refresh requests
      window.addEventListener('requestHealthRefresh', () => {
        console.log('üîÑ HealthDashboard: Manual refresh requested');
        this.refreshAllServices();
      });

      // Check for existing persistent health data on page load
      // This ensures the test-health page immediately shows current status
      setTimeout(() => {
        this.checkForExistingHealthData();
      }, 100); // Small delay to ensure health system is initialized
    }

    private checkForExistingHealthData(): void {
      // Check for the most recent consolidated health data
      // This should be immediately available if user navigated from another page
      const latestHealthData = (window as any).__latestConsolidatedHealthData;

      if (latestHealthData && latestHealthData.services) {
        console.log('üéØ HealthDashboard: Found existing consolidated health data on page load', latestHealthData);
        this.updateFromGlobalHealthData(latestHealthData);
        return;
      }

      // Fallback: Check for persistent timestamp at least
      const healthState = (window as any).__healthStatusState;
      if (healthState && healthState.lastHealthTimestamp) {
        const lastCheckedEl = document.getElementById('overall-last-checked');
        if (lastCheckedEl) {
          try {
            const timeString = new Date(healthState.lastHealthTimestamp).toLocaleTimeString();
            lastCheckedEl.textContent = `Last Checked at: ${timeString}`;
            console.log('üéØ HealthDashboard: Found persistent timestamp, updating display while waiting for service data');
          } catch (error) {
            console.warn('üö® HealthDashboard: Failed to format persistent timestamp');
          }
        }
        return;
      }

      console.log('üéØ HealthDashboard: No persistent health data found - this appears to be initial page load');
      console.log('üéØ HealthDashboard: Keeping "Last Checked at: Never" until first poll data arrives');
    }
    
    private updateFromGlobalHealthData(healthData: any): void {
      if (!healthData || !healthData.services) return;

      const { services, timestamp } = healthData;
      console.log('üîÑ HealthDashboard: Updating dashboard with global health data', services);

      // Update each service card with the global health data
      Object.entries(services).forEach(([serviceName, serviceData]: [string, any]) => {
        if (serviceData) {
          const checker = this.serviceCheckers.get(serviceName === 'database' ? 'postgres' : serviceName === 'cache' ? 'redis' : serviceName);
          if (checker) {
            console.log(`üîÑ HealthDashboard: Updating ${serviceName} card`, serviceData);
            checker.updateUI(serviceData);
          }
        }
      });

      // Update overall status display based on persistent health data
      this.updateOverallStatusFromPersistentData(services, timestamp);
    }

    private updateOverallStatusFromPersistentData(services: any, timestamp?: number): void {
      // Count services (frontend, backend, database, cache)
      const serviceList = ['frontend', 'backend', 'database', 'cache'];
      const loadedServices = serviceList.filter(service => services[service] && services[service].status);
      const upServices = serviceList.filter(service => services[service] && services[service].status === 'up');

      const totalCount = serviceList.length; // Always 4 services
      const loadedCount = loadedServices.length;
      const upCount = upServices.length;

      let statusText: string;
      let summaryText: string;
      let statusIndicatorClass: string;

      if (loadedCount === 0) {
        // No data loaded yet
        statusText = 'Loading&hellip;';
        summaryText = 'Loading system status from persistent health data...';
        statusIndicatorClass = 'bg-blue-500 animate-pulse';
      } else if (upCount === totalCount) {
        // All services operational
        statusText = '‚úÖ All Services Operational';
        summaryText = `${upCount} of ${totalCount} services loaded`;
        statusIndicatorClass = 'bg-green-500';
      } else {
        // Some services have issues
        statusText = '‚ö†Ô∏è Service Issues, Please Review Details';
        summaryText = `${upCount} of ${totalCount} services loaded`;
        statusIndicatorClass = 'bg-red-500';
      }

      // Update UI elements
      const statusIndicator = document.getElementById('overall-status-indicator');
      const statusTextEl = document.getElementById('overall-status-text');
      const summaryEl = document.getElementById('overall-status-summary');
      const lastCheckedEl = document.getElementById('overall-last-checked');

      if (statusIndicator) {
        statusIndicator.className = `w-4 h-4 rounded-full transition-colors duration-300 ${statusIndicatorClass}`;
      }
      if (statusTextEl) statusTextEl.textContent = statusText;
      if (summaryEl) summaryEl.textContent = summaryText;

      if (lastCheckedEl && timestamp) {
        try {
          const lastCheckedTime = new Date(timestamp).toLocaleTimeString();
          lastCheckedEl.textContent = `Last Checked at: ${lastCheckedTime}`;
        } catch (error) {
          lastCheckedEl.textContent = 'Last Checked at: Unknown';
        }
      }

      console.log('üéØ HealthDashboard: Updated overall status', {
        statusText,
        summaryText,
        upCount,
        totalCount,
        loadedCount
      });
    }

    private bindEventListeners(): void {
      // Global controls
      document.getElementById('refresh-all')?.addEventListener('click', () => this.refreshAllServices());
      document.getElementById('toggle-auto-refresh')?.addEventListener('click', () => this.autoRefreshManager.toggle());
      document.getElementById('export-report')?.addEventListener('click', () => this.dataExporter.exportHealthReport());
      document.getElementById('test-connectivity')?.addEventListener('click', () => this.connectivityTester.testNetworkConnectivity());
      
      // Network connectivity test buttons
      document.getElementById('test-cors')?.addEventListener('click', () => this.connectivityTester.testCORSPolicies());
      document.getElementById('test-latency')?.addEventListener('click', () => this.connectivityTester.testNetworkLatency());
      
      // Debug controls
      document.getElementById('copy-debug')?.addEventListener('click', () => this.copyDebugOutput());
      document.getElementById('clear-debug')?.addEventListener('click', () => DebugLogger.clear());
      
      // Historical data controls
      document.getElementById('copy-historical-data')?.addEventListener('click', () => this.copyHistoricalData());
      document.getElementById('clear-historical-data')?.addEventListener('click', () => this.clearHistoricalData());

      // Individual service refresh buttons
      document.getElementById('backend-refresh')?.addEventListener('click', () => this.refreshService('backend'));
      document.getElementById('postgres-refresh')?.addEventListener('click', () => this.refreshService('postgres'));
      document.getElementById('redis-refresh')?.addEventListener('click', () => this.refreshService('redis'));
      // Frontend refresh button removed - frontend status is self-evident if page loads
      // Grafana and Prometheus refresh buttons removed - services are now quick access links

      // Individual service details buttons
      document.getElementById('backend-details')?.addEventListener('click', () => this.showServiceDetails('backend'));
      document.getElementById('postgres-details')?.addEventListener('click', () => this.showServiceDetails('postgres'));
      document.getElementById('redis-details')?.addEventListener('click', () => this.showServiceDetails('redis'));
      document.getElementById('frontend-details')?.addEventListener('click', () => this.showServiceDetails('frontend'));
      // Grafana and Prometheus details buttons removed - services are now quick access links

      // External links for monitoring services moved to Backend card quick access buttons

      // Advanced testing
      document.getElementById('test-redis-connection')?.addEventListener('click', () => this.refreshService('redis'));

      // Data management
      document.getElementById('clear-data')?.addEventListener('click', () => this.performanceMonitor.clearData());
      document.getElementById('copy-data')?.addEventListener('click', () => this.dataExporter.copyRawData());

      // Footer polling integration
      document.getElementById('toggle-footer-polling')?.addEventListener('click', () => this.toggleFooterPolling());
    }

    private initializeLiveClock(): void {
      // Initialize timezone display
      const updateTimezoneInfo = () => {
        const timezone = getCurrentTimezone();
        const abbreviation = getTimezoneAbbreviation();
        UIUpdater.updateTextElement('timezone-info', `Timezone: ${timezone} (${abbreviation})`);
      };

      // Update clock every second
      const updateClock = () => {
        const now = Date.now();
        const timeString = formatTimestamp(new Date(now), {
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit',
          timeZoneName: 'short'
        });
        UIUpdater.updateTextElement('live-clock', timeString);
      };

      // Initial updates
      updateTimezoneInfo();
      updateClock();

      // Set up intervals
      setInterval(updateClock, 1000);

      // Listen for settings changes to update timezone
      window.addEventListener('settingsChanged', (event: any) => {
        const settings = event.detail;
        if (settings.timezone) {
          updateTimezoneInfo();
          updateClock(); // Immediately update with new timezone
        }
      });
    }

    async refreshService(serviceName: string): Promise<void> {
      console.log(`üîÑ HealthDashboard: Individual refresh requested for ${serviceName}`);
      
      // Get button elements
      const refreshButton = document.getElementById(`${serviceName}-refresh`);
      const originalContent = refreshButton?.innerHTML || '';
      
      if (refreshButton) {
        // Phase 1: Refreshing... 
        refreshButton.innerHTML = `
          <svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
          </svg>
          <span>Refreshing...</span>
        `;
        refreshButton.setAttribute('disabled', 'true');
      }

      // Trigger individual service refresh via global health system
      window.dispatchEvent(new CustomEvent('requestServiceRefresh', {
        detail: { serviceName }
      }));
      
      // Re-enable button after short delay (UI feedback)
      setTimeout(() => {
        if (refreshButton) {
          refreshButton.innerHTML = originalContent;
          refreshButton.removeAttribute('disabled');
        }
      }, 1500);

        console.log(`‚úÖ Individual service refresh completed for ${serviceName}`);
    }

    async refreshAllServices(): Promise<void> {
      console.log('üîÑ HealthDashboard: Manual refresh triggered');
      UIUpdater.updateTextElement('overall-status-text', 'Refreshing all services...');
      UIUpdater.updateTextElement('overall-status-summary', 'Please wait...');

      // Trigger global health refresh instead of individual service calls
      this.healthDataConsumer.requestRefresh();

      // Update last refresh time immediately
      TimestampUpdater.updateLastRefresh('last-update-time');

      console.log('üîÑ HealthDashboard: Manual refresh request sent to global health system');
    }

    private updateOverallStatus(): void {
      const results = Array.from(this.latestResults.values());
      if (results.length === 0) return;

      const upCount = results.filter(r => r.status === 'up').length;
      const totalCount = results.length;
      
      let overallStatus: ServiceStatus;
      let statusText: string;
      let summaryText: string;

      if (upCount === totalCount) {
        overallStatus = 'up';
        statusText = '‚úÖ All Systems Operational';
        summaryText = `${totalCount} services running normally`;
      } else if (upCount > totalCount / 2) {
        overallStatus = 'degraded';
        statusText = '‚ö†Ô∏è System Issues Detected';
        summaryText = `${upCount}/${totalCount} services operational`;
      } else {
        overallStatus = 'down';
        statusText = 'üö® System Issues Detected';
        summaryText = `${totalCount - upCount} service(s) offline`;
      }

      UIUpdater.updateStatusIndicator('overall-status-indicator', overallStatus);
      UIUpdater.updateTextElement('overall-status-text', statusText);
      UIUpdater.updateTextElement('overall-status-summary', summaryText);
      
      // Update last checked timestamp whenever overall status is updated
      const now = new Date();
      const timeString = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
      UIUpdater.updateTextElement('overall-last-checked', `Last Checked at: ${timeString}`);
    }

    private updateHealthSummary(): void {
      const summary = {
        timestamp: formatTimestamp(new Date()),
        timezone: getTimezoneAbbreviation(),
        services: Object.fromEntries(
          Array.from(this.latestResults.entries()).map(([service, result]) => [
            service,
            {
              status: result.status,
              message: result.message,
              responseTime: result.metrics.responseTime
            }
          ])
        )
      };

      UIUpdater.updateElement('health-summary', JSON.stringify(summary, null, 2));
      UIUpdater.updateElement('historical-data', this.performanceMonitor.getHistoricalData());
    }

    private toggleFooterPolling(): void {
      // Placeholder for footer polling integration
      const isEnabled = document.getElementById('toggle-footer-polling')?.textContent?.includes('Enable');
      
      if (isEnabled) {
        UIUpdater.updateTextElement('toggle-footer-polling', 'Disable Footer Polling');
        UIUpdater.updateTextElement('footer-auto-polling', 'Auto-Polling: Enabled', 'up');
        UIUpdater.updateTextElement('footer-running-status', 'Running Status: Active', 'up');
      } else {
        UIUpdater.updateTextElement('toggle-footer-polling', 'Enable Footer Polling');
        UIUpdater.updateTextElement('footer-auto-polling', 'Auto-Polling: Disabled', 'error');
        UIUpdater.updateTextElement('footer-running-status', 'Running Status: Inactive', 'error');
      }
      
      UIUpdater.updateTextElement('footer-last-poll', `Last Poll: ${new Date().toLocaleTimeString()}`);
    }

    // NEW: Card-based monitoring system (DRY + Single Source of Truth)
    private initializeCardBasedMonitoring(): void {
      // Listen for custom events from service card scripts
      window.addEventListener('serviceCardComplete', ((event: CustomEvent) => {
        const { serviceName, result } = event.detail;
        this.onServiceCardComplete(serviceName, result);
      }) as EventListener);
      
      // Start monitoring - wait for cards to load
      setTimeout(() => {
        if (!this.cardLoadingStarted) {
          this.startCardBasedMonitoring();
        }
      }, 1000); // Give cards time to initialize
    }

    private startCardBasedMonitoring(): void {
      this.cardLoadingStarted = true;
      console.log('üîÑ Starting card-based monitoring - header shows MEASURING...');
      
      // Header already shows "MEASURING...." from HTML
      // Cards will emit events as they complete
    }

    private onServiceCardComplete(serviceName: string, result: IServiceResult): void {
      console.log(`üìä Service card complete: ${serviceName}`, result);
      this.cardResults.set(serviceName.toLowerCase(), result);
      
      // Check if all expected services have reported
      this.updateHeaderFromCardResults();
    }

    private updateHeaderFromCardResults(): void {
      const completedServices = Array.from(this.cardResults.keys());
      const totalExpected = this.expectedCardServices.length;
      const completed = completedServices.length;
      
      console.log(`üìà Real-time card progress: ${completed}/${totalExpected} services reporting`, completedServices);
      
      // REAL-TIME: Update header immediately with current known results
      if (completed > 0) {
        const results = Array.from(this.cardResults.values());
        const upCount = results.filter(r => r.status === 'up' || r.status === 'healthy').length;
        const totalCount = totalExpected; // Always show total expected, not just completed
        const completedCount = results.length;
        
        let overallStatus: ServiceStatus;
        let statusText: string;
        let summaryText: string;
        
        // Determine status based on completed services
        if (completedCount === totalCount && upCount === totalCount) {
          overallStatus = 'up';
          statusText = '‚úÖ All Systems Operational';
          summaryText = `${totalCount} services running normally`;
        } else if (completedCount < totalCount) {
          // Still measuring some services
          overallStatus = 'degraded';
          statusText = `üîÑ MEASURING.... (${completedCount}/${totalCount})`;
          summaryText = `${upCount} up, ${completedCount - upCount} down, ${totalCount - completedCount} checking...`;
        } else if (upCount > totalCount / 2) {
          overallStatus = 'degraded';
          statusText = '‚ö†Ô∏è System Issues Detected';
          summaryText = `${upCount}/${totalCount} services operational`;
        } else {
          overallStatus = 'down';
          statusText = 'üö® System Issues Detected';
          summaryText = `${totalCount - upCount} service(s) offline`;
        }
        
        console.log('üîÑ Real-time header update:', { overallStatus, statusText, summaryText });
        
        UIUpdater.updateStatusIndicator('overall-status-indicator', overallStatus);
        UIUpdater.updateTextElement('overall-status-text', statusText);
        UIUpdater.updateTextElement('overall-status-summary', summaryText);
        
        // Update last checked timestamp
        const now = new Date();
        const timeString = now.toLocaleTimeString();
        UIUpdater.updateTextElement('overall-last-checked', `Last Checked at: ${timeString}`);
      }
    }

    private startInitialChecks(): void {
      // Start with a small delay to ensure DOM is ready
      setTimeout(() => {
        // Load both system performance metrics AND initial connectivity status
        this.refreshAllServices();
        // Run connectivity test once on initial load (no auto-refresh, just initial population)
        this.connectivityTester.testNetworkConnectivity();
      }, 500);
    }

    // Public method for external access
    getLatestResults(): Map<string, IServiceResult> {
      return this.latestResults;
    }

    // Historical data management methods
    copyDebugOutput(): void {
      // Get debug logs from DebugLogger
      const debugLogs = DebugLogger.getAllLogs();
      const debugText = debugLogs.length > 0 
        ? debugLogs.join('\n') 
        : 'No debug output available. Run a network test to generate debug logs.';
      
      navigator.clipboard.writeText(debugText).then(() => {
        // Show success feedback (matching historical data pattern)
        const button = document.getElementById('copy-debug');
        if (button) {
          const originalContent = button.innerHTML;
          button.innerHTML = `<svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
          </svg>
          <span>Copied!</span>`;
          button.classList.remove('bg-blue-500/20', 'text-blue-300', 'hover:bg-blue-500/30');
          button.classList.add('bg-green-500/20', 'text-green-300');
          
          setTimeout(() => {
            button.innerHTML = originalContent;
            button.classList.remove('bg-green-500/20', 'text-green-300');
            button.classList.add('bg-blue-500/20', 'text-blue-300', 'hover:bg-blue-500/30');
          }, 2000);
        }
      }).catch(() => {
        // Show error feedback
        const button = document.getElementById('copy-debug');
        if (button) {
          const originalContent = button.innerHTML;
          button.innerHTML = `<svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
          </svg>
          <span>Failed</span>`;
          button.classList.remove('bg-blue-500/20', 'text-blue-300', 'hover:bg-blue-500/30');
          button.classList.add('bg-red-500/20', 'text-red-300');
          
          setTimeout(() => {
            button.innerHTML = originalContent;
            button.classList.remove('bg-red-500/20', 'text-red-300');
            button.classList.add('bg-blue-500/20', 'text-blue-300', 'hover:bg-blue-500/30');
          }, 2000);
        }
      });
    }

    copyHistoricalData(): void {
      const historicalDataElement = document.getElementById('historical-data');
      const data = historicalDataElement?.textContent || 'No historical data available';
      
      navigator.clipboard.writeText(data).then(() => {
        // Show success feedback
        const button = document.getElementById('copy-historical-data');
        if (button) {
          const originalContent = button.innerHTML;
          button.innerHTML = `<svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
          </svg>
          <span>Copied!</span>`;
          button.classList.remove('bg-blue-500/20', 'text-blue-300', 'hover:bg-blue-500/30');
          button.classList.add('bg-green-500/20', 'text-green-300');
          
          setTimeout(() => {
            button.innerHTML = originalContent;
            button.classList.remove('bg-green-500/20', 'text-green-300');
            button.classList.add('bg-blue-500/20', 'text-blue-300', 'hover:bg-blue-500/30');
          }, 2000);
        }
      }).catch((error) => {
        console.error('Failed to copy historical data:', error);
        // Show error feedback
        const button = document.getElementById('copy-historical-data');
        if (button) {
          const originalContent = button.innerHTML;
          button.innerHTML = `<svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
          </svg>
          <span>Failed</span>`;
          button.classList.remove('bg-blue-500/20', 'text-blue-300', 'hover:bg-blue-500/30');
          button.classList.add('bg-red-500/20', 'text-red-300');
          
          setTimeout(() => {
            button.innerHTML = originalContent;
            button.classList.remove('bg-red-500/20', 'text-red-300');
            button.classList.add('bg-blue-500/20', 'text-blue-300', 'hover:bg-blue-500/30');
          }, 2000);
        }
      });
    }

    clearHistoricalData(): void {
      // Show confirmation dialog
      const confirmed = confirm('Are you sure you want to clear all historical data? This action cannot be undone.');
      
      if (confirmed) {
        // Clear the performance monitor history
        this.performanceMonitor.clearHistory();
        
        // Update the historical data display
        UIUpdater.updateElement('historical-data', 'Historical data cleared. New data will appear here as services are checked...');
        
        // Show success feedback
        const button = document.getElementById('clear-historical-data');
        if (button) {
          const originalContent = button.innerHTML;
          button.innerHTML = `<svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
          </svg>
          <span>Cleared!</span>`;
          button.classList.remove('bg-red-500/20', 'text-red-300', 'hover:bg-red-500/30');
          button.classList.add('bg-green-500/20', 'text-green-300');
          
          setTimeout(() => {
            button.innerHTML = originalContent;
            button.classList.remove('bg-green-500/20', 'text-green-300');
            button.classList.add('bg-red-500/20', 'text-red-300', 'hover:bg-red-500/30');
          }, 2000);
        }
      }
    }

    showServiceDetails(serviceName: string): void {
      const result = this.latestResults.get(serviceName);
      if (!result) {
        alert(`No data available for ${serviceName} service. Please refresh the service first.`);
        return;
      }

      // Create detailed information modal
      const modal = document.createElement('div');
      modal.className = 'fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4';
      modal.innerHTML = `
        <div class="glass-card max-w-2xl w-full max-h-[80vh] overflow-y-auto">
          <div class="p-6">
            <div class="flex items-center justify-between mb-4">
              <h2 class="text-2xl font-bold text-white flex items-center space-x-3">
                <span class="text-3xl">${this.getServiceIcon(serviceName)}</span>
                <span>${serviceName.charAt(0).toUpperCase() + serviceName.slice(1)} Service Details</span>
              </h2>
              <button id="close-modal" class="glass-button p-2 bg-red-500/20 text-red-300 hover:bg-red-500/30">
                <svg class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                </svg>
              </button>
            </div>
            
            <div class="space-y-4">
              <!-- Status Section -->
              <div class="bg-black/30 rounded-lg p-4">
                <h3 class="text-white font-semibold mb-3">Current Status</h3>
                <div class="grid grid-cols-2 gap-4 text-sm">
                  <div>Status: <span class="ml-2 ${this.getStatusColor(result.status)}">${result.status.toUpperCase()}</span></div>
                  <div>Message: <span class="ml-2 text-white">${result.message}</span></div>
                  <div>Response Time: <span class="ml-2 text-blue-400">${result.metrics.responseTime || 0}ms</span></div>
                  <div>Last Check: <span class="ml-2 text-purple-400">${formatRelativeTime(result.timestamp)}</span></div>
                </div>
              </div>

              <!-- Metrics Section -->
              <div class="bg-black/30 rounded-lg p-4">
                <h3 class="text-white font-semibold mb-3">Service Metrics</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-3 text-sm">
                  ${Object.entries(result.metrics)
                    .filter(([key]) => key !== 'responseTime')
                    .map(([key, value]) => 
                      `<div><span class="text-white/70">${key.charAt(0).toUpperCase() + key.slice(1).replace(/([A-Z])/g, ' $1')}:</span> <span class="ml-2 text-blue-400">${value}</span></div>`
                    ).join('')}
                </div>
              </div>

              <!-- Timestamp Section -->
              <div class="bg-black/30 rounded-lg p-4">
                <h3 class="text-white font-semibold mb-3">Timing Information</h3>
                <div class="text-sm space-y-2">
                  <div>Last Updated: <span class="ml-2 text-blue-400">${formatTimestamp(new Date(result.timestamp))}</span></div>
                  <div>Relative Time: <span class="ml-2 text-purple-400">${formatRelativeTime(result.timestamp)}</span></div>
                  <div>Timezone: <span class="ml-2 text-green-400">${getCurrentTimezone()} (${getTimezoneAbbreviation()})</span></div>
                </div>
              </div>

              <!-- Raw Data Section -->
              <div class="bg-black/30 rounded-lg p-4">
                <h3 class="text-white font-semibold mb-3">Raw JSON Data</h3>
                <pre class="text-xs text-purple-400 whitespace-pre-wrap overflow-x-auto bg-black/20 p-3 rounded">${JSON.stringify(result, null, 2)}</pre>
              </div>

              <!-- Action Buttons -->
              <div class="flex space-x-3 pt-4">
                <button id="refresh-service" class="glass-button px-4 py-2 bg-blue-500/20 text-blue-300 hover:bg-blue-500/30">
                  üîÑ Refresh Service
                </button>
                <button id="copy-details" class="glass-button px-4 py-2 bg-green-500/20 text-green-300 hover:bg-green-500/30">
                  üìã Copy Details
                </button>
              </div>
            </div>
          </div>
        </div>
      `;

      // Add modal to page
      document.body.appendChild(modal);

      // Bind modal event listeners
      modal.querySelector('#close-modal')?.addEventListener('click', () => {
        document.body.removeChild(modal);
      });

      modal.querySelector('#refresh-service')?.addEventListener('click', () => {
        this.refreshService(serviceName);
        document.body.removeChild(modal);
      });

      modal.querySelector('#copy-details')?.addEventListener('click', () => {
        navigator.clipboard.writeText(JSON.stringify(result, null, 2)).then(() => {
          const button = modal.querySelector('#copy-details') as HTMLButtonElement;
          if (button) {
            const originalText = button.innerHTML;
            button.innerHTML = '‚úÖ Copied!';
            setTimeout(() => {
              button.innerHTML = originalText;
            }, 2000);
          }
        });
      });

      // Close modal when clicking outside
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          document.body.removeChild(modal);
        }
      });
    }

    private getServiceIcon(serviceName: string): string {
      const icons: Record<string, string> = {
        frontend: 'üåê',
        backend: '‚öôÔ∏è',
        postgres: 'üóÑÔ∏è',
        redis: 'üî¥',
        grafana: 'üìä',
        prometheus: 'üìà'
      };
      return icons[serviceName] || 'üîß';
    }

    private getStatusColor(status: string): string {
      const colors: Record<string, string> = {
        up: 'text-green-400',
        degraded: 'text-yellow-400',
        down: 'text-red-400',
        error: 'text-red-400'
      };
      return colors[status] || 'text-gray-400';
    }
  }

  // =============================================================================
  // APPLICATION INITIALIZATION (Single Point of Entry)
  // =============================================================================

  // Initialize the dashboard when the DOM is fully loaded
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      new HealthDashboard();
    });
  } else {
    new HealthDashboard();
  }

</script>

<!-- Client-Side Metrics Collection Script -->
<script type="module" src="/src/scripts/client-side-metrics.ts"></script>

<!-- Backend Service Metrics Collection Script -->
<script type="module" src="/src/scripts/backend-metrics.ts"></script>

<!-- PostgreSQL Database Metrics Collection Script -->
<script type="module" src="/src/scripts/postgres-metrics.ts"></script>

<!-- Redis Cache Metrics Collection Script -->
<script type="module" src="/src/scripts/redis-metrics.ts"></script>

<!-- Grafana and Prometheus monitoring moved to Backend service sub-components -->