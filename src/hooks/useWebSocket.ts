/**\n * useWebSocket Hook\n * Real-time WebSocket integration for job updates\n * Implements reconnection logic and event handling\n */\n\nimport { useEffect, useRef, useState, useCallback } from 'react';\nimport type { WebSocketEvent, ConversionJob } from '../types';\n\ninterface UseWebSocketOptions {\n  url: string;\n  reconnectAttempts?: number;\n  reconnectInterval?: number;\n  onJobUpdate?: (job: ConversionJob) => void;\n  onJobComplete?: (job: ConversionJob) => void;\n  onJobError?: (job: ConversionJob) => void;\n  onConnectionChange?: (connected: boolean) => void;\n}\n\ninterface UseWebSocketReturn {\n  isConnected: boolean;\n  connectionState: 'connecting' | 'connected' | 'disconnected' | 'error';\n  lastMessage: WebSocketEvent | null;\n  send: (data: any) => void;\n  reconnect: () => void;\n  disconnect: () => void;\n}\n\n/**\n * Custom hook for WebSocket connection with auto-reconnection\n */\nexport const useWebSocket = ({\n  url,\n  reconnectAttempts = 5,\n  reconnectInterval = 3000,\n  onJobUpdate,\n  onJobComplete,\n  onJobError,\n  onConnectionChange,\n}: UseWebSocketOptions): UseWebSocketReturn => {\n  const [connectionState, setConnectionState] = useState<'connecting' | 'connected' | 'disconnected' | 'error'>('disconnected');\n  const [lastMessage, setLastMessage] = useState<WebSocketEvent | null>(null);\n  const [reconnectCount, setReconnectCount] = useState(0);\n  \n  const wsRef = useRef<WebSocket | null>(null);\n  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const pingIntervalRef = useRef<NodeJS.Timeout | null>(null);\n  const isManualClose = useRef(false);\n  \n  // Clean up function\n  const cleanup = useCallback(() => {\n    if (reconnectTimeoutRef.current) {\n      clearTimeout(reconnectTimeoutRef.current);\n      reconnectTimeoutRef.current = null;\n    }\n    \n    if (pingIntervalRef.current) {\n      clearInterval(pingIntervalRef.current);\n      pingIntervalRef.current = null;\n    }\n    \n    if (wsRef.current) {\n      wsRef.current.close();\n      wsRef.current = null;\n    }\n  }, []);\n  \n  // Connect to WebSocket\n  const connect = useCallback(() => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\n      return;\n    }\n    \n    cleanup();\n    \n    try {\n      setConnectionState('connecting');\n      wsRef.current = new WebSocket(url);\n      \n      wsRef.current.onopen = () => {\n        console.log('WebSocket connected');\n        setConnectionState('connected');\n        setReconnectCount(0);\n        \n        if (onConnectionChange) {\n          onConnectionChange(true);\n        }\n        \n        // Start heartbeat\n        pingIntervalRef.current = setInterval(() => {\n          if (wsRef.current?.readyState === WebSocket.OPEN) {\n            wsRef.current.send(JSON.stringify({ type: 'ping' }));\n          }\n        }, 30000);\n      };\n      \n      wsRef.current.onmessage = (event) => {\n        try {\n          const message: WebSocketEvent = JSON.parse(event.data);\n          setLastMessage(message);\n          \n          // Handle different message types\n          switch (message.type) {\n            case 'job_update':\n              if (onJobUpdate && message.payload.data) {\n                onJobUpdate(message.payload.data as ConversionJob);\n              }\n              break;\n              \n            case 'job_complete':\n              if (onJobComplete && message.payload.data) {\n                onJobComplete(message.payload.data as ConversionJob);\n              }\n              break;\n              \n            case 'job_error':\n              if (onJobError && message.payload.data) {\n                onJobError(message.payload.data as ConversionJob);\n              }\n              break;\n              \n            case 'connection_status':\n              console.log('Connection status:', message.payload.data);\n              break;\n              \n            default:\n              console.log('Unknown message type:', message.type);\n          }\n        } catch (error) {\n          console.error('Failed to parse WebSocket message:', error);\n        }\n      };\n      \n      wsRef.current.onclose = (event) => {\n        console.log('WebSocket disconnected:', event.code, event.reason);\n        \n        if (pingIntervalRef.current) {\n          clearInterval(pingIntervalRef.current);\n          pingIntervalRef.current = null;\n        }\n        \n        if (onConnectionChange) {\n          onConnectionChange(false);\n        }\n        \n        if (!isManualClose.current && reconnectCount < reconnectAttempts) {\n          setConnectionState('connecting');\n          const delay = reconnectInterval * Math.pow(1.5, reconnectCount);\n          \n          console.log(`Attempting to reconnect in ${delay}ms (attempt ${reconnectCount + 1}/${reconnectAttempts})`);\n          \n          reconnectTimeoutRef.current = setTimeout(() => {\n            setReconnectCount(prev => prev + 1);\n            connect();\n          }, delay);\n        } else {\n          setConnectionState('disconnected');\n        }\n      };\n      \n      wsRef.current.onerror = (error) => {\n        console.error('WebSocket error:', error);\n        setConnectionState('error');\n      };\n      \n    } catch (error) {\n      console.error('Failed to create WebSocket connection:', error);\n      setConnectionState('error');\n    }\n  }, [url, reconnectCount, reconnectAttempts, reconnectInterval, onJobUpdate, onJobComplete, onJobError, onConnectionChange, cleanup]);\n  \n  // Send message through WebSocket\n  const send = useCallback((data: any) => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\n      wsRef.current.send(JSON.stringify(data));\n    } else {\n      console.warn('WebSocket is not connected. Cannot send message:', data);\n    }\n  }, []);\n  \n  // Manual reconnect\n  const reconnect = useCallback(() => {\n    isManualClose.current = false;\n    setReconnectCount(0);\n    connect();\n  }, [connect]);\n  \n  // Manual disconnect\n  const disconnect = useCallback(() => {\n    isManualClose.current = true;\n    cleanup();\n    setConnectionState('disconnected');\n    \n    if (onConnectionChange) {\n      onConnectionChange(false);\n    }\n  }, [cleanup, onConnectionChange]);\n  \n  // Initialize connection on mount\n  useEffect(() => {\n    isManualClose.current = false;\n    connect();\n    \n    // Cleanup on unmount\n    return () => {\n      isManualClose.current = true;\n      cleanup();\n    };\n  }, [connect, cleanup]);\n  \n  // Handle page visibility changes\n  useEffect(() => {\n    const handleVisibilityChange = () => {\n      if (document.visibilityState === 'visible') {\n        // Page became visible, reconnect if needed\n        if (connectionState === 'disconnected' && !isManualClose.current) {\n          console.log('Page became visible, attempting to reconnect...');\n          reconnect();\n        }\n      }\n    };\n    \n    document.addEventListener('visibilitychange', handleVisibilityChange);\n    \n    return () => {\n      document.removeEventListener('visibilitychange', handleVisibilityChange);\n    };\n  }, [connectionState, reconnect]);\n  \n  // Handle online/offline events\n  useEffect(() => {\n    const handleOnline = () => {\n      console.log('Browser came online, attempting to reconnect...');\n      if (!isManualClose.current) {\n        reconnect();\n      }\n    };\n    \n    const handleOffline = () => {\n      console.log('Browser went offline');\n      setConnectionState('error');\n    };\n    \n    window.addEventListener('online', handleOnline);\n    window.addEventListener('offline', handleOffline);\n    \n    return () => {\n      window.removeEventListener('online', handleOnline);\n      window.removeEventListener('offline', handleOffline);\n    };\n  }, [reconnect]);\n  \n  return {\n    isConnected: connectionState === 'connected',\n    connectionState,\n    lastMessage,\n    send,\n    reconnect,\n    disconnect,\n  };\n};\n\nexport default useWebSocket;"